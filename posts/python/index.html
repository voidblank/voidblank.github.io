<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Python知识点总结目录" /><meta name="author" content="voidblank" /><meta property="og:locale" content="en_US" /><meta name="description" content="Python 知识点总结目录 数值数据类型 整数:int 浮点型:float,double,decimal 复数:complex" /><meta property="og:description" content="Python 知识点总结目录 数值数据类型 整数:int 浮点型:float,double,decimal 复数:complex" /><link rel="canonical" href="https://voidblank.github.io/posts/python/" /><meta property="og:url" content="https://voidblank.github.io/posts/python/" /><meta property="og:site_name" content="voidblank" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-10T16:36:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Python知识点总结目录" /><meta name="twitter:site" content="@voidblank" /><meta name="twitter:creator" content="@voidblank" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"voidblank"},"description":"Python 知识点总结目录 数值数据类型 整数:int 浮点型:float,double,decimal 复数:complex","headline":"Python知识点总结目录","dateModified":"2021-04-10T16:36:00+08:00","url":"https://voidblank.github.io/posts/python/","datePublished":"2021-04-10T16:36:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://voidblank.github.io/posts/python/"},"@context":"https://schema.org"}</script><title>Python知识点总结目录 | voidblank</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://imgur.com/oEa1xeJ.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">voidblank</a></div><div class="site-subtitle font-italic">just a blog!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/voidblank" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/voidblank" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['cy1245171920','outlook.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Python知识点总结目录</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Python知识点总结目录</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> voidblank </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 10, 2021, 4:36 PM +0800" prep="on" > Apr 10 <i class="unloaded">2021-04-10T16:36:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8306 words">46 min</span></div></div><div class="post-content"><h1 id="python-知识点总结目录">Python 知识点总结目录</h1><h2 id="数值数据类型">数值数据类型</h2><ul><li>整数:int<li>浮点型:float,double,decimal<li>复数:complex</ul><h2 id="序列和容器">序列和容器</h2><h3 id="str字符串">str字符串</h3><ul><li>可以使用for进行遍历<li>可以使用”“或是’‘,视情况而定，一般最外层用””<li><code class="language-plaintext highlighter-rouge">r"C:\string"</code>相当于<code class="language-plaintext highlighter-rouge">"C:\\string"</code><li>在string中使用’’’ ‘'’可以换行存储字符串,保留换行格式<li>在print中使用string及参数的方法:<ol><li>%方法:<code class="language-plaintext highlighter-rouge">print("I'm %s and I'm %s years old!"%(name, age))</code><li>逗号方法:<code class="language-plaintext highlighter-rouge">print("I'm",name,"and I'm",age,"years old!")</code><li>format方法:<code class="language-plaintext highlighter-rouge">print("I'm {} and I'm {} years old!".format(name, age))</code>&lt;/br&gt;具体方法参考后续format函数<li>首字母大写<code class="language-plaintext highlighter-rouge">str.capitalize()</code><li>某字符串在母串的出现次数<code class="language-plaintext highlighter-rouge">str.count(substr, beg, end)</code><li>是否以某字符串结尾<code class="language-plaintext highlighter-rouge">str.isendwith(substr, beg, end)</code><li>将\t替换成空格<code class="language-plaintext highlighter-rouge">str.expandtabs(tabsize = 0)</code><li>判断是否全为字母,数字<code class="language-plaintext highlighter-rouge">str.isalnum()</code><li>判断是否全为字母 <code class="language-plaintext highlighter-rouge">str.isalpha()</code><li>判断是否全为数字<code class="language-plaintext highlighter-rouge">str.isdigit()</code><li>判断是否符合标题化<code class="language-plaintext highlighter-rouge">str.istitle()</code><li>将seq中的每个元素进行链接<code class="language-plaintext highlighter-rouge">str.join(seq)</code>&lt;/br&gt;注意:如果seq是list,则每个元素间都以str链接;如果seq是str,则每个字符间都以str链接<li>寻找substr在str中的索引,不存在返回-1<code class="language-plaintext highlighter-rouge">str.find(substr, beg, end)</code>&lt;/br&gt;注:也可以使用rfind进行右查找<li>寻找substr在str中的索引,不存在会报一个异常<code class="language-plaintext highlighter-rouge">str.index(substr, beg, end)</code>&lt;/br&gt;注:也可以使用rindex进行右查找<li>左对齐至width个字符,如果不足用substr进行填充<code class="language-plaintext highlighter-rouge">str.ljust(width, substr)</code>&lt;/br&gt;注:也可以使用rjust进行右填充<li>全体字母小写<code class="language-plaintext highlighter-rouge">str.lower()</code>&lt;/br&gt;全体字母大写<code class="language-plaintext highlighter-rouge">str.upper()</code>&lt;/br&gt;全体字母大小写调换<code class="language-plaintext highlighter-rouge">str.swapcase()</code><li>将oldstr替换成newstr<code class="language-plaintext highlighter-rouge">str.replace(old, new, max)</code>最多max次<li>删除左侧的指定substr<code class="language-plaintext highlighter-rouge">str.lstrip(substr)</code>&lt;/br&gt;删除右侧的指定substr<code class="language-plaintext highlighter-rouge">str.rstrip(substr)</code>&lt;/br&gt;删除两侧的指定substr<code class="language-plaintext highlighter-rouge">str.strip(substr)</code>&lt;/br&gt;注:如果substr不是单一字符,那么只要包含其中之一就会执行,直至下一个字符不在substr之内<li>将str标题化<code class="language-plaintext highlighter-rouge">str.title()</code>&lt;/br&gt;标题化是指每个单词的首字母大写<li>将str切割成三个部分,形成一个元组,包括strFront,substr,strBehind<code class="language-plaintext highlighter-rouge">str.partition(substr)</code><li>将字符串转换成dict,可以快速计数每个字符的个数<code class="language-plaintext highlighter-rouge">Counter(str)</code>&lt;/br&gt;注1:需要<code class="language-plaintext highlighter-rouge">from collections import Counter</code>&lt;/br&gt;注2:也可以如此:&lt;/br&gt;<code class="language-plaintext highlighter-rouge">result = {}</code>&lt;/br&gt; <code class="language-plaintext highlighter-rouge">for i in string : result[i] = string.count(i)</code><li>将str以substr为分隔符切割,如果num有值则切割num个<code class="language-plaintext highlighter-rouge">str.split(substr, num)</code>&lt;/br&gt;注:不会保留substr&lt;/br&gt;input时,这种用法可以快速获得输入列表<code class="language-plaintext highlighter-rouge">List = list(map(int, input().split()))</code></ol></ul><h3 id="list列表">list列表</h3><ul><li>本质上是长度可变的连续数组<li>复制方法:&lt;/br&gt;浅拷贝:<code class="language-plaintext highlighter-rouge">listCopy = list1[:]</code>或<code class="language-plaintext highlighter-rouge">listCopy = list1.copy()</code>&lt;/br&gt;深层拷贝:<code class="language-plaintext highlighter-rouge">listCopy = copy.deepcopy(list1)</code><li>空列表:<code class="language-plaintext highlighter-rouge">listNone = [None]*10</code><li>添加至末尾:<code class="language-plaintext highlighter-rouge">list.append(entry)</code>或<code class="language-plaintext highlighter-rouge">list.append(copy.deepcopy(entry))</code><li>删除方法:<ol><li><code class="language-plaintext highlighter-rouge">list.remove(entry)</code><li><code class="language-plaintext highlighter-rouge">list.pop()</code>末尾<li><code class="language-plaintext highlighter-rouge">del list[a]</code></ol></ul><h3 id="tuple元组">tuple元组</h3><ul><li>创建后不可改变,只可读的容器<li>可以使用list(Tuple)来强转为list进行操作<li>如果元组内有list,那么可以对该list的元素进行操作<li>tuple的创建:<code class="language-plaintext highlighter-rouge">t = ()</code>或<code class="language-plaintext highlighter-rouge">t = (1, )</code>&lt;/br&gt;注:若只有一个成员,必须加逗号,否则变量等同于内部变量,如<code class="language-plaintext highlighter-rouge">t = ("1")</code>等同于<code class="language-plaintext highlighter-rouge">t = "1"</code><li>具名元组:(效率高于字典)</ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="kn">import</span> <span class="nn">collections</span>
	<span class="n">User</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">'User'</span><span class="p">,</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'age'</span><span class="p">,</span> <span class="s">'position'</span><span class="p">])</span><span class="c1">#定义
</span>	<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s">'Jack'</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s">'loc'</span><span class="p">)</span><span class="c1">#创建一个实例
</span>	<span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="mi">22</span><span class="p">)</span><span class="c1">#改变一个属性
</span>	<span class="k">print</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">user</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="c1">#调用,两种效果相同
</span></pre></table></code></div></div><h3 id="set集合">set集合</h3><ul><li>创建方法:<ol><li><code class="language-plaintext highlighter-rouge">Set = {"a","b","c"}</code><li><code class="language-plaintext highlighter-rouge">Set = set("abc")</code></ol><li>添加元素<ol><li><code class="language-plaintext highlighter-rouge">set.add('abc')</code><li><code class="language-plaintext highlighter-rouge">set.update('abc')</code><li><code class="language-plaintext highlighter-rouge">set.update({'abc'})</code>注意这与第二条不同</ol><li>删除元素<ol><li><code class="language-plaintext highlighter-rouge">set.remove(entry)</code>若entry不存在会报错<li><code class="language-plaintext highlighter-rouge">set.discard(entry)</code>不会报错<li><code class="language-plaintext highlighter-rouge">set.pop()</code> 删除末尾元素</ol><li>两个集合的关系<ol><li>求在set1中不在set2中的元素<code class="language-plaintext highlighter-rouge">set1.difference(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 - set2</code>效率更高<li>将两个set中不同元素删除<code class="language-plaintext highlighter-rouge">set1.difference_update(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 -= set2</code>效率更高<li>求交集<code class="language-plaintext highlighter-rouge">set1.intersection(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 &amp; set2</code>效率更高<li>求并集<code class="language-plaintext highlighter-rouge">set1.union(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 | set2</code>效率更高<li>是否有相同元素<code class="language-plaintext highlighter-rouge">set1.isdisjoint(set2)</code><li>是否是子集<code class="language-plaintext highlighter-rouge">set1.issubset(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 &lt;= set2</code>效率更高<li>是否是父集<code class="language-plaintext highlighter-rouge">set1.issuperset(set2)</code>&lt;/br&gt;注:<code class="language-plaintext highlighter-rouge">set1 &gt;= set2</code>效率更高</ol></ul><h3 id="dict字典">dict字典</h3><ul><li>本质上是hashtable(哈希表,或是散列表),最坏时间复杂度是O(n)<li>如果一个字典原来存储大量元素,但后来大部分被删除了,只留下少部分元素,那么在遍历现在的字典时,依然是按照字典的最大数目来遍历的,所以尽可能新建一个字典来遍历<li>一一映射<li>效率很高,但是对内存使用较大,优化方面可以考虑使用tuple代替dict<li>已知key获取value:<code class="language-plaintext highlighter-rouge">dict.get(key,default)</code>,如果不存在key则返回default&lt;/br&gt;注:这种方法优于dict[key],因为它会报错&lt;/br&gt;建议使用<code class="language-plaintext highlighter-rouge">dict.setdefault(key, default)</code>,若有key则返回key的value,否则设置key的value为default并返回default<li>将dict变成一个zip元组:<code class="language-plaintext highlighter-rouge">zip(dict.values(), dict.keys())</code>,便于求值<li>判断是否有指定key:<code class="language-plaintext highlighter-rouge">if findKey in dict</code><li>可以使用collections模块下的OrderedDict(有序字典)<ul><li>会按照录入顺序进行排序<li>清除元素:<code class="language-plaintext highlighter-rouge">oDict.clear()</code><li>将指定元素放至尾部:<code class="language-plaintext highlighter-rouge">oDict.move_to_end(key, last = True)</code><ul><li>key:指定元素的键<li>last:如果为True,则移至尾部;如果为False,则移至首部.默认为True</ul><li>删除指定key值:<code class="language-plaintext highlighter-rouge">oDict.pop(key)</code><ul><li>返回key对应的value值<li>如果不存在会报错</ul><li>如果需要自己定义一个dict,那么可以继承<code class="language-plaintext highlighter-rouge">collections.UserDict</code>,不建议直接继承dict</ul></ul><h3 id="queue队列">queue队列</h3><ul><li>先进先出,元素添加在队首又从队尾取出<li>本质上是一个deque<li>需要<code class="language-plaintext highlighter-rouge">import queue</code><li>创建一个队列:<code class="language-plaintext highlighter-rouge">q = queue.Queue(size)</code><ul><li>size:队列大小,不填写的话默认为0,即无限</ul><li>添加元素:<code class="language-plaintext highlighter-rouge">q.put(item, block, Timeout)</code><ul><li>item:要添加的元素<li>block:若队列已满是否阻塞,默认为True,即阻塞<li>Timeout:若阻塞了,最多相应的时长,超时还阻塞则会报错,默认为None,即永不超时</ul><li>出队:<code class="language-plaintext highlighter-rouge">q.get(block, Timeout)</code><ul><li>返回item,同时该元素也会从队列中删除</ul><li>判断相关:<ul><li><code class="language-plaintext highlighter-rouge">q.full()</code>:判断队列是否已满<li><code class="language-plaintext highlighter-rouge">q.empty()</code>:判断队列是否为空,一般可用于while-queue.get()时的判断<li><code class="language-plaintext highlighter-rouge">q.qsize()</code>:返回当前队列长度<li><code class="language-plaintext highlighter-rouge">q.task_done()</code>:每次调用<code class="language-plaintext highlighter-rouge">get()</code>都会得到一个任务(task),调用表示完成一个任务,几个put就需要调用几次,否则会阻塞join<li><code class="language-plaintext highlighter-rouge">q.join()</code>:阻塞等待队列任务执行完毕,配合<code class="language-plaintext highlighter-rouge">queue.task_done()</code>使用</ul></ul><h3 id="deque双向队列">deque双向队列</h3><ul><li>需要<code class="language-plaintext highlighter-rouge">from collections import deque</code><li>依旧是先进先出,首尾优化但中间元素处理较慢<li>创建一个双向队列:<code class="language-plaintext highlighter-rouge">dq = deque(iterable, maxlen)</code><ul><li>iterable:任意可迭代对象<li>maxlen:最大长度,一旦设定就无法更改,可选参数</ul><li>旋转队列:<code class="language-plaintext highlighter-rouge">dq.rotate(n)</code><ul><li>如果n大于0,那么队列最右边的n个元素会被移到最左边&lt;/br&gt;如果n小于0,那么队列的最左边的n个元素会被移到最右边</ul><li>添加元素:<ul><li>在队尾添加元素:<code class="language-plaintext highlighter-rouge">dq.append(entry)</code><li>在队首添加元素:<code class="language-plaintext highlighter-rouge">dq.appendleft(entry)</code><li>在队尾添加可迭代对象:<code class="language-plaintext highlighter-rouge">dq.extend(iterable)</code><li>在队首添加可迭代对象:<code class="language-plaintext highlighter-rouge">dq.extendleft(iterable)</code>&lt;/br&gt;注:在这种情况下,iterable内的顺序会颠倒<li>注意:如果元素已达到maxlen,那么队首/队尾元素会被删除,这取决于你是使用append/extend方法还是appendleft/extendleft方法</ul><li>删除元素:<ul><li>在队尾删除元素:<code class="language-plaintext highlighter-rouge">dq.pop()</code><li>在队头删除元素:<code class="language-plaintext highlighter-rouge">dq.popleft()</code><li>返回被删除的元素</ul></ul><h2 id="数据类型的判断">数据类型的判断</h2><ul><li>type()<ul><li>不考虑继承关系</ul><li>isinstance()<ul><li>考虑继承关系</ul><li>可变与不可变类型:<ul><li>list,dict可变类型<li>int,float,string,tuple不可变类型</ul></ul><h2 id="运算符">运算符</h2><ul><li>a**b:a的b次方<li>a//b:a整除b<li>in/not in:判断是否在序列内<li>is/not is/id():判断二者是否相同,==判断二者是否__eqls__<li>类的运算符:<ul><li>+<ul><li><code class="language-plaintext highlighter-rouge">__add__</code>或反向<code class="language-plaintext highlighter-rouge">__radd__</code><li>当类可以使用切片时,可以这样定义使用<code class="language-plaintext highlighter-rouge">itertools.zip_longest(self, other, fillvalue = 0.0)</code>来定义<code class="language-plaintext highlighter-rouge">__add__</code>方法<li>反向操作符<code class="language-plaintext highlighter-rouge">__radd__</code>可以直接<code class="language-plaintext highlighter-rouge">return self + other</code>,在无特殊要求的情况下<li>这种方法设计的<code class="language-plaintext highlighter-rouge">+</code>只适用于可迭代对象<li>在<code class="language-plaintext highlighter-rouge">__add__</code>方法中,可以使用try-except <code class="language-plaintext highlighter-rouge">return NotImplemented</code>的方法来调用<code class="language-plaintext highlighter-rouge">__radd__</code>方法&lt;/br&gt;注:防止某些情况下出现的TypeError</ul><li>*<ul><li><code class="language-plaintext highlighter-rouge">__mul__</code>或反向<code class="language-plaintext highlighter-rouge">__rmul__</code><li>一般来说需要判断mul的第二个参数scalar是否为数字,建议使用<code class="language-plaintext highlighter-rouge">isinstance(scalar, numbers.Real)</code>&lt;/br&gt;注:当scalar类型为decimal.Decimal时,返回False<li>反向操作符<code class="language-plaintext highlighter-rouge">__rmul__</code>可以直接<code class="language-plaintext highlighter-rouge">return self * scalar</code>,在无特殊要求的情况下</ul></ul></ul><h2 id="循环">循环</h2><ul><li>for<ul><li>实现iterator即可用for进行迭代<li>可以使用_作占位符,比如 <code class="language-plaintext highlighter-rouge">for i,_ in x:</code><li>可以写<code class="language-plaintext highlighter-rouge">for-else</code>语句块,效果为:在for正常结束的情况下(不是因为break退出),会执行else语句</ul><li>while<ul><li>同cpp/java<li>可以写<code class="language-plaintext highlighter-rouge">while-else</code>语句块,效果为:在while正常结束的情况下(不是因为break退出),会执行else语句</ul></ul><h2 id="变量">变量</h2><ul><li>全局变量<ul><li>在非全局域声明:<code class="language-plaintext highlighter-rouge">global var</code></ul><li>局部变量<ul><li>在嵌套中调用:<code class="language-plaintext highlighter-rouge">nonlocal var</code></ul></ul><h2 id="函数">函数</h2><ul><li>没有return时返回None<li>参数不传递,除非是list&lt;/br&gt;注:不要使用可变参数作为参数的默认值!<li>多个参数时可以这样传递:<code class="language-plaintext highlighter-rouge">person(name = n, age = a)</code><li>*args代表元组,**kwargs代表字典<li>匿名函数lambda<ul><li><code class="language-plaintext highlighter-rouge">lambda arg1, arg2: arg1 + arg2</code><li>如果为了代码更pythonic,那么应该尽量使用lambda表达式;但为了代码更方便阅读,应该不使用lambda表达式</ul><li>函数文档<ul><li>在函数的第一行用’'’doctext’'’来解释函数<li>调用:<code class="language-plaintext highlighter-rouge">func.__doc__</code></ul></ul><h2 id="内置函数">内置函数</h2><ul><li><code class="language-plaintext highlighter-rouge">filter(function, sequence)</code><ul><li>过滤不符合条件的元素<li>返回的是迭代器<li>例:<code class="language-plaintext highlighter-rouge">filter（lambda x:x%2 == 0, List)</code><li>例:</ul><li><code class="language-plaintext highlighter-rouge">map(function, iterable1, iterable2, ...)</code><ul><li>多个序列的函数映射后的值<li>返回的是迭代器<li>例:<code class="language-plaintext highlighter-rouge">map(lambda x,y :x*y + 2, x, y)</code><li>例:<code class="language-plaintext highlighter-rouge">map(lambda x,y,z: x + y + z, [0,1,2], [4,5,6,7,8], [9,1])</code>此时返回的个数为2个</ul><li><code class="language-plaintext highlighter-rouge">reduce(function, iterable)</code><ul><li>将序列压缩运算的结果<li><code class="language-plaintext highlighter-rouge">from functools import reduce</code><li>例:<code class="language-plaintext highlighter-rouge">reduce(lambda x,y: x + y, List)</code>,List是一个0~10的list,返回的结果是list的各项的和</ul><li><code class="language-plaintext highlighter-rouge">zip(list1, list2)</code><ul><li>将两个list打包成一个元组,返回iterable<li>容量不同时按最小的打包<li><code class="language-plaintext highlighter-rouge">zip(*zippedTuple)</code>进行解包,返回两个元组<li>如果想按照大容量的一方进行打包,可以使用<code class="language-plaintext highlighter-rouge">itertools.zip_longest(it1, it2, ..., fillvalue = None)</code></ul><li><code class="language-plaintext highlighter-rouge">all(it)</code><ul><li>当it中所有都为真值时返回true<li>all([])返回true</ul><li><code class="language-plaintext highlighter-rouge">any(it)</code><ul><li>当it中有至少一个真值时返回true<li>any([])返回false</ul><li><code class="language-plaintext highlighter-rouge">str.format(var1, var2, var3, ...)</code></ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>	<span class="o">&gt;&gt;&gt;</span><span class="s">"{} {} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var3</span><span class="p">)</span>
	<span class="n">var1</span><span class="p">,</span><span class="n">var2</span><span class="p">,</span><span class="n">var3</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{2} {1} {3}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var3</span><span class="p">)</span>
	<span class="n">var2</span><span class="p">,</span><span class="n">var1</span><span class="p">,</span><span class="n">var3</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{var2} {var3} {var1}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var3</span><span class="p">)</span>
	<span class="n">var2</span><span class="p">,</span><span class="n">var3</span><span class="p">,</span><span class="n">var1</span>
	<span class="o">&gt;&gt;&gt;</span><span class="n">site</span> <span class="o">=</span> <span class="p">{</span><span class="s">"var1"</span><span class="p">:</span> <span class="n">var1</span><span class="p">,</span> <span class="s">"var2"</span><span class="p">:</span> <span class="n">var2</span><span class="p">,</span> <span class="s">"var3"</span><span class="p">:</span> <span class="n">var3</span><span class="p">}</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{var1} {var2} {var3}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="o">**</span><span class="n">site</span><span class="p">)</span>
	<span class="n">var1</span><span class="p">,</span><span class="n">var2</span><span class="p">,</span><span class="n">var3</span>
	<span class="o">&gt;&gt;&gt;</span><span class="n">List</span> <span class="o">=</span> <span class="p">[</span><span class="s">"var1"</span><span class="p">,</span> <span class="s">"var2"</span><span class="p">,</span> <span class="s">"var3"</span><span class="p">]</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{0[0]} {0[1]} {0[2]}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">List</span><span class="p">)</span><span class="c1">#0是必须的
</span>	<span class="n">var1</span><span class="p">,</span><span class="n">var2</span><span class="p">,</span><span class="n">var3</span>
	<span class="o">&gt;&gt;&gt;</span><span class="n">myValue</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="c1">#自定义Class Vector,__init__(self, a, b)
</span>	<span class="o">&gt;&gt;&gt;</span><span class="s">"{0.x} {0.y}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">myValue</span><span class="p">)</span>
	<span class="mi">6</span> <span class="mi">10</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{:+.2f} {:+.2f}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="o">-</span><span class="mf">3.556</span><span class="p">,</span><span class="mf">1.774</span><span class="p">)</span>
	<span class="o">-</span><span class="mf">3.55</span> <span class="mf">1.77</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{:&gt;2d} {:&lt;2d} {:^2d}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
	<span class="p">(</span><span class="n">右对齐</span><span class="p">,</span><span class="n">宽度2</span><span class="p">)</span><span class="mi">1</span> <span class="p">(</span><span class="n">左对齐</span><span class="p">,</span><span class="n">宽度2</span><span class="p">)</span><span class="mi">2</span> <span class="p">(</span><span class="n">居中</span><span class="p">,</span><span class="n">宽度2</span><span class="p">)</span><span class="mi">3</span>
	<span class="o">&gt;&gt;&gt;</span><span class="s">"{:,} {:.2%} {:.2e}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="mi">100000</span><span class="p">,</span><span class="mf">0.233</span><span class="p">,</span><span class="mi">100000</span><span class="p">)</span>
	<span class="mi">100</span><span class="p">,</span><span class="mi">000</span> <span class="mf">23.30</span><span class="o">%</span> <span class="mf">1.00e+05</span>
</pre></table></code></div></div><h2 id="迭代器">迭代器</h2><ul><li>用于访问集合元素或是用于class的遍历<li>创建一个指定类的iterator:<code class="language-plaintext highlighter-rouge">myit = iter(myClass)</code></ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>	<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
		<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">return</span> <span class="bp">self</span>
		<span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
				<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">a</span>
				<span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="nb">StopIteration</span>
			<span class="k">return</span> <span class="n">x</span>
</pre></table></code></div></div><h2 id="生成器">生成器</h2><ul><li>含有yield的函数<li>用于迭代<li>在迭代执行过程中,每次迭代都是执行到yield语句时停止,将yield值返回;下次迭代从yield语句之后的语句开始执行</ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="k">def</span> <span class="nf">Fibonaci</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="k">yield</span> <span class="n">a</span>
			<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">Fibonaci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="c1">#f是生成器
</span></pre></table></code></div></div><h2 id="文件io">文件IO</h2><h3 id="open">open()</h3><ul><li><code class="language-plaintext highlighter-rouge">open(filepath\filename, access_mode, buffering)</code><ul><li>打开文件<li>参数:文件名,文件打开的模式,寄存值<li>access_mode:<ul><li>t 文本模式<li>x 新建一个文件,如果已存在会报错<li>b 二进制模式<li>+ 可读可写的打开文件<li>r 只读打开文件<li>rb 二进制格式打开只读文件<li>r+ 读写打开文件<li>rb+ 二进制格式打开读写文件<li>w 只写打开文件,会清除原有文件内容,若不存在则新建<li>wb 二进制格式打开只写文件,与w类似<li>w+ 读写打开文件,与w类似<li>wb+ 二进制格式打开读写文件,与wb类似<li>a 只写打开文件,用于在文件尾进行追加内容,若不存在则新建<li>ab 二进制格式打开只写文件,与a类似<li>a+ 读写打开文件,与a类似<li>ab+ 二进制格式打开读写文件,与ab类似</ul></ul></ul><h3 id="read">read()</h3><ul><li><code class="language-plaintext highlighter-rouge">file.read()</code><ul><li>读文件的一个字符串<ul><li><code class="language-plaintext highlighter-rouge">file.readline()</code><ul><li>读文件的一行</ul><li><code class="language-plaintext highlighter-rouge">file.readlines()</code><ul><li>读文件直至结尾(EOF),可以使用for循环来逐行遍历</ul><li><code class="language-plaintext highlighter-rouge">file.tell()</code><ul><li>返回一个当前位置的指针</ul><li><code class="language-plaintext highlighter-rouge">file.write(str)</code><ul><li>写入指定字符串,可以用b’str’来写入二进制格式字符串</ul><li><code class="language-plaintext highlighter-rouge">file.close()</code><ul><li>关闭文件,每次文件使用结束后都要调用一次<li>可以使用<code class="language-plaintext highlighter-rouge">file.closed()</code>来获取是否关闭该文件</ul></ul></ul></ul><h2 id="os相关">OS相关</h2><ul><li><code class="language-plaintext highlighter-rouge">os.chdir(path)</code>:改变当前目录<li><code class="language-plaintext highlighter-rouge">os.getcwd()</code>:返回当前目录<li><code class="language-plaintext highlighter-rouge">os.open(file, flags, mode)</code>:打开文件,flags是参数,mode默认为0777<li><code class="language-plaintext highlighter-rouge">os.remove(path)</code>:删除文件,若path是文件夹,则抛出OSError<li><code class="language-plaintext highlighter-rouge">os.rmdir(path)</code>:删除指定空目录,若目录非空,则抛出OSError<li><code class="language-plaintext highlighter-rouge">os.rename(src, dst)</code>:将文件名称从src改为dst<li><code class="language-plaintext highlighter-rouge">os.listdir(path)</code>:获取path目录下的所有文件及子目录,返回一个列表<li><code class="language-plaintext highlighter-rouge">os.path.join(path, filename)</code>:将文件名和路径结合起来,可以搭配上一个使用3<li><code class="language-plaintext highlighter-rouge">os.path.isdir(path)</code>:判断path是否为目录</ul><h2 id="异常">异常</h2><ul><li>用来处理异常的代码</ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>	<span class="k">try</span><span class="c1">#可能产生异常的代码块
</span>		<span class="n">code</span>
	<span class="k">except</span> <span class="nb">Exception</span><span class="c1">#捕获异常后执行
</span>		<span class="n">code</span>
	<span class="k">else</span><span class="c1">#没产生异常则执行
</span>		<span class="n">code</span>
	<span class="k">finally</span><span class="c1">#无论如何都会执行
</span>		<span class="n">code</span>
</pre></table></code></div></div><p>对于文件来说,可以使用with来处理异常 with如果有异常会报错,但无论是否有异常都会<code class="language-plaintext highlighter-rouge">flie.close()</code> 可以在with外使用try-except来捕获异常</p><h2 id="类">类</h2><ul><li>自定义类:<code class="language-plaintext highlighter-rouge">class className(superObject):</code><li>如果父类是object则省略不写<li>类中的public与private:<ul><li><code class="language-plaintext highlighter-rouge">property = None #public</code><li><code class="language-plaintext highlighter-rouge">_property = None #private,只有自己和子类能读取</code><li><code class="language-plaintext highlighter-rouge">__property = None #private,只有自己能读取</code><li>注:python的private不是真private,借助装饰器@property可以达到效果好一些的private</ul><li>类的静态方法声明:在方法上一行加<code class="language-plaintext highlighter-rouge">@staticmethod</code><li>类的类方法声明:在方法上一行加<code class="language-plaintext highlighter-rouge">@classmethod</code><ul><li>二者区别:<li>静态方法没有参数,类方法有一个参数cls<li>静态方法只能由类调用，不能改变类;类方法可以由类和对象调用,可以改变类</ul><li>类的类型:<ul><li><code class="language-plaintext highlighter-rouge">__class__</code>:获取类的class属性,但是这个可以更改,不建议<li><code class="language-plaintext highlighter-rouge">type(cls)</code>:获取类的类别,和<code class="language-plaintext highlighter-rouge">__class__</code>无关,获取的是类的实际类别,建议使用</ul><li>类的专有方法(魔方方法)<ul><li><code class="language-plaintext highlighter-rouge">__init__(self, entry, ...)</code>#构造器<li><code class="language-plaintext highlighter-rouge">__str__(self)</code>#用于将类转换成易于人阅读的形式<li><code class="language-plaintext highlighter-rouge">__repr__(self)</code>#用于将类转换成解释器读取的形式,一般重写该方法就可以不重写str方法<li><code class="language-plaintext highlighter-rouge">__iter__(self)</code>#迭代器<li><code class="language-plaintext highlighter-rouge">__next__(self)</code>#迭代规则<li><code class="language-plaintext highlighter-rouge">__getattr__(self, error)</code>#如果某个属性不存在却被调用，则会先执行该方法<li><code class="language-plaintext highlighter-rouge">__getitem__(self, key)</code>#使得类的实例可以如下调用:&lt;/br&gt;myClass[key]&lt;/br&gt;此时会执行getitem方法<li><code class="language-plaintext highlighter-rouge">__call__(self)</code>#使得可以直接调用这个类的实例<li><code class="language-plaintext highlighter-rouge">__del__(self)</code>#删除object,会先执行该函数,具体跳转<code class="language-plaintext highlighter-rouge">垃圾回收</code><li><code class="language-plaintext highlighter-rouge">__cmp__(self)</code>#用于同类之间的比较<li><code class="language-plaintext highlighter-rouge">__new__(self)</code>#先于init之前执行,详细请看下面的code</ul></ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>	<span class="k">class</span> <span class="nc">AbsNumber</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
			<span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"this is init def!"</span><span class="p">)</span>
		
		<span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
			<span class="n">cls</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"this is new def!"</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">int</span><span class="p">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="c1">#最终value并没有绝对值化,但是new先于init执行了
</span>		<span class="c1">#如果__new__的return没有返回cls实例,那么就不会执行__init__方法
</span></pre></table></code></div></div><h3 id="类的优化">类的优化</h3><ul><li><code class="language-plaintext highlighter-rouge">__slots__</code>属性:<ul><li>在类中定义该属性,可以将原本由dict保存的数据转换,极大的节省内存并缩短程序执行时间<li>用法:<code class="language-plaintext highlighter-rouge">__slots__ = ('__entry1', '__entry2')</code><li>如果定义了slots却没有将所有的属性写入,那么没被写入的属性将作废,即:实例只能拥有slots里列出的属性<li>子类也需要定义<code class="language-plaintext highlighter-rouge">__slots__</code>,解释器会自动忽略继承的<code class="language-plaintext highlighter-rouge">__slots__</code>属性<li>如果不需要数百万个实例,或某些其他情况,那么不建议使用该属性进行优化</ul></ul><h3 id="类的继承">类的继承</h3><ul><li>子类的判断:<ul><li>issubclass(subClass, superClass),isinstance</ul><li>虚拟子类:<ul><li>注册虚拟子类时在子类名称上使用<code class="language-plaintext highlighter-rouge">@superClass.register</code>,即可将注册为虚拟子类<li>虚拟子类也能被issubclass,isinstance判断,但实际上不会继承任何虚拟父类的方法<li>父类必须是抽象基类</ul><li>多重继承:<ul><li>python中子类可以同时继承多个父类<li>当调用父类函数时,会按照继承的顺序来调用;如果显式继承的父类不含有这个方法,那么还会继续查找所有超类的方法<li>可以使用<code class="language-plaintext highlighter-rouge">__mro__</code>方法来查看父类继承的顺序,从左到右排列,第一个是类自身</ul></ul><h2 id="正则表达式">正则表达式</h2><ul><li>用正则表达式来进行字符串匹配,在某些情况下很有用<li>需要<code class="language-plaintext highlighter-rouge">import re</code><li>单个匹配:<code class="language-plaintext highlighter-rouge">re.search(pattern, str, flags = 0).span()</code><ul><li>pattern:正则表达式<li>str:要检查的字符串<li>flags:标志位,用于控制正则匹配的方式,默认为0<li>如果没有匹配,返回None<li>.span()加上该语句则返回一个元组,(start,end)</ul><li>替换匹配字符串:<code class="language-plaintext highlighter-rouge">re.sub(pattern, repl, str, count = 0, flags = 0)</code><ul><li>repl:替换的字符串<li>count:替换的最大次数,默认为0,即全部替换</ul><li>生成一个正则表达式对象:<code class="language-plaintext highlighter-rouge">re.compile(pattern, flags)</code><ul><li>flags:匹配模式<ol><li>re.I忽略大小写<li>re.L特殊字符集,依赖环境字符库<li>re.M多行模式<li>re.S任意字符<li>re.U特殊字符集,依赖Unicode字符库<li>re.X忽略空格和#后面的注释</ol></ul><li>全部匹配:<code class="language-plaintext highlighter-rouge">pattern.findall(str, pos, endpos)</code><ul><li>pattern：由<code class="language-plaintext highlighter-rouge">re.compile()</code>返回的正则表达式对象<li>str:要检查的字符串<li>pos:字符串起始位置,默认是0<li>endpos:字符串结束位置,默认是结尾<li>返回的是一个列表<li>建议:使用<code class="language-plaintext highlighter-rouge">re.findall(pattern, str, flags = 0)</code>,效率更高,同时节省内存<li>可以使用<code class="language-plaintext highlighter-rouge">re.finditer(pattern, str, flags = 0)</code>来获得一个iterator,便于使用for来遍历结果</ul><li>全部匹配的迭代器:<code class="language-plaintext highlighter-rouge">re.finditer(pattern, str)</code><ul><li>会查找str内所有匹配pattern规则的字段<li>返回的是一个iterable<li>遍历方法:<code class="language-plaintext highlighter-rouge">for it in re.finditer(pattern, str)</code><ul><li>注意:it也是一个iterable<li>想要获取位置,使用it.span()<li>想要获取字段,使用it.group()</ul></ul></ul><h2 id="排序">排序</h2><ul><li><code class="language-plaintext highlighter-rouge">list.sort(cmp, key, reverse)</code><ul><li>cmp:排序方法,默认为空时按升序排列,如果自定义cmp,返回1位大于,返回-1小于,返回0相等<li>key:用来比较的元素,默认为空<li>reverse:True时降序,False时升序,默认为False<li>没有返回值,直接改变list本身<li>只能用于list</ul><li><code class="language-plaintext highlighter-rouge">sorted(iterable, cmp, key, reverse)</code><ul><li>iterable:可迭代对象,例如容器,类等<li>返回一个排完序的对象,原对象不发生变化<li>类型保持不变<li>适当的情况下可以使用key和reverse来替代cmp,因为cmp会持续调用,而key和reverse只会调用一次,效率更高</ul><li>bisect模块:<ul><li>本质上是二分查找<li>在list中,效率:bisect&gt;循环二分查找&gt;递归二分查找<li>bisect分为left查找和right查找,默认是right查找<li>区别:left返回的是原序列中和被插入元素相等的位置,right返回的是相等元素之后的位置&lt;/br&gt;例:对于[0,2,4]中插入[2],left的position在1,right的position在2<li>查找位置:<code class="language-plaintext highlighter-rouge">bisect.bisect_right(myList, needle, lo = 0, hi = None)</code><ul><li>myList:要查找的列表<li>needle:要插入的值<li>lo:列表的最小范围,默认是0,不能小于0<li>hi:列表的最大范围,默认是len(myList)<li>返回的是一个int,代表可以插入的position</ul><li>插入位置:<code class="language-plaintext highlighter-rouge">bisect.insort_right(myList, needle, lo = 0, hi = None)</code><ul><li>二分查找后直接插入,效率高于先bisect_right再insert()<li>没有返回值</ul></ul></ul><h2 id="设计模式">设计模式</h2><h3 id="单例模式">单例模式</h3><ul><li>确保某个类只有一个实例存在<li>为对象提供一个访问点,使程序可以全局访问该对象<li>控制共享资源的并行访问<li>实现的方法:<ul><li>使用<code class="language-plaintext highlighter-rouge">__new__</code>方法(推荐)<li>使用import导包的方法<li>使用装饰器的方法<li>基于元类的单例实现</ul></ul><h3 id="策略模式">策略模式</h3><ul><li>定义一系列算法,将它们一一封装起来,并使他们可以互相替换<li>优点:<ol><li>算法可以自由切换<li>避免使用多重条件判断<li>扩展性良好</ol><li>缺点:<ol><li>策略类会增多<li>所有策略类对外暴露</ol><li>使用场景:<ol><li>如果一个系统内有多个类,他们之间的区别只在于他们的行为,那么使用策略模式可以动态的让一个对象在许多行为中选择一个行为<li>一个系统需要动态的在多种算法中选择一种<li>如果一个对象有许多行为,如果不用恰当的模式,这些行为只好通过使用多重条件选择语句实现</ol><li>注意:如果一个系统的策略多于4个,那么需要考虑使用混合模式,解决策略类膨胀的问题</ul><h3 id="命令模式">命令模式</h3><ul><li>将一个请求封装成一个对象,从而使使用者可以用不同的请求对客户进行参数化<li>优点:<ol><li>降低系统的耦合度<li>新的命令可以很容易的加入到系统中去</ol><li>缺点:<ul><li>使用命令模式可能会导致某些系统有过多的具体命令类</ul><li>使用场景:<ul><li>模拟CMD</ul></ul><h2 id="装饰器">装饰器</h2><ul><li>可调用对象,其参数是另一个函数(被装饰的函数)<li>注:也有类装饰器<li>装饰器可以是一个一阶函数,也可以是嵌套函数<li>一般情况下可以通过在装饰器函数上使用<code class="language-plaintext highlighter-rouge">@wraps</code>进行装饰,保证被装饰的函数类型不发生变化<ul><li>注:需要<code class="language-plaintext highlighter-rouge">from functools import wraps</code></ul><li>闭包:<ul><li>函数的嵌套函数及嵌套函数需要用到的变量<li>调用其他域(上层)的变量时,如果变量类型是不可变,那么就需要使用<code class="language-plaintext highlighter-rouge">nonlocal</code>来声明</ul><li>常用装饰器:<ul><li><code class="language-plaintext highlighter-rouge">@classmethod</code>:类方法,可以在类没有实例化的情况下使用,对类进行操作<li><code class="language-plaintext highlighter-rouge">@staticmethod</code>:静态方法,不能对类进行操作,何时使用都可以<li><code class="language-plaintext highlighter-rouge">@property</code>:描述符,可以用来设置只读类属性和用于对属性进行限制定义<li><code class="language-plaintext highlighter-rouge">@lru_cache(maxsize, typed)</code>可以对函数进行缓存&lt;/br&gt;注:需要<code class="language-plaintext highlighter-rouge">import functools</code><li><code class="language-plaintext highlighter-rouge">@singledispatch</code>可以对函数进行装饰,使其可以进行类似于重载的效果<ul><li>其他函数可以指定类型,函数名建议使用_,因为名字没有意义<li>需要<code class="language-plaintext highlighter-rouge">import functools</code></ul></ul><li>参数化装饰器:<ul><li>创建一个装饰器工厂函数,由它来获取参数,并将参数传给嵌套的装饰器函数(相当于原装饰器变为嵌套)</ul><li>使用<code class="language-plaintext highlighter-rouge">__call__</code>来实现装饰器(类装饰器)<ul><li>在类的<code class="language-plaintext highlighter-rouge">__call__</code>方法下编写装饰器,然后在外部引用它<li>下面是例子</ul></ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">class</span> <span class="nc">C1</span><span class="p">:</span>
		<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
			<span class="p">...</span>
		<span class="k">def</span>  <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
			<span class="c1">#在这里编写嵌套函数做装饰器
</span>
	<span class="c1">#这里的字符串可以随意填写,相当于创建了一个C1实例,name赋值为'NAME'
</span>	<span class="o">@</span><span class="n">C1</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">)</span>
	<span class="k">def</span> <span class="nf">func1</span><span class="p">():</span>
		<span class="p">...</span>
	<span class="c1">#执行func1,会发现C1的装饰器功能实现了
</span>	<span class="n">func1</span><span class="p">()</span>	
</pre></table></code></div></div><h2 id="垃圾回收">垃圾回收</h2><ul><li><code class="language-plaintext highlighter-rouge">__del__</code>:<ul><li>该方法将会在以下两种情况下调用:<ol><li>使用<code class="language-plaintext highlighter-rouge">del 对象</code>时调用<li>在对象的引用计数为0时调用</ol><li>调用后,第一种情况下删除名称,第二种情况下对象会被垃圾回收</ul><li>Python垃圾回收:<ul><li>引用计数机制:<ul><li>每个对象都有一个<code class="language-plaintext highlighter-rouge">ob_ref</code>,用来记录当前对象的被引用次数,出现以下情况,则计数器+1<ol><li>对象被创建 <code class="language-plaintext highlighter-rouge">a = 0</code><li>对象被引用 <code class="language-plaintext highlighter-rouge">b = a</code><li>对象作为参数被传入 <code class="language-plaintext highlighter-rouge">func(a)</code><li>对象作为一个元素被保存在容器中 <code class="language-plaintext highlighter-rouge">List = {"a": a, "b": 2}</code></ol><li>当出现以下情况,则计数器-1<ol><li>对象的显示别名被销毁 <code class="language-plaintext highlighter-rouge">del a</code><li>对象的引用别名被赋予新的对象 <code class="language-plaintext highlighter-rouge">a = 99</code><li>对象离开它的作用域,那么作用域内局部变量的计数器-1 (func执行完毕时)<li>对象所在容器被销毁,或对象被从容器中删除</ol><li>当计数器为0时,对象被垃圾回收<li>优点:<ol><li>高效<li>运行时没有停顿<li>对象有确定的生命周期<li>易于实现</ol><li>缺点:<ol><li>维护计数消耗资源<li>无法解决循环引用问题</ol></ul><li>标记-清除机制<ul><li>用于处理循环引用问题<li>主要处理容器类对象,如list,dict,tuple,instance等<li>使用“零代链表”来追踪活跃的对象,将创建出的对象放入链表,同时有一个“一代链表”,用于存储零代链表遍历后计数大于0的对象<li>将被del的容器对象计数-1,将不为0的放置于一代链表<li>这时,将会再次遍历一代链表中的对象,查看是否引用零代链表的对象,如果有,那就把被引用的对象从零代链表移至一代链表<li>一代链表遍历结束后,将零代链表的对象垃圾回收</ul><li>分代回收<ul><li>基于标记 - 清除机制<li>每次进行标记 - 清除后,存活下来的引用将代数+1<li>对于代数越高的对象(等同于存活时间久),进行标记 - 清除的时间间隔越长</ul></ul></ul><h2 id="上下文管理器">上下文管理器</h2><p>-</p><ul><li>含有<code class="language-plaintext highlighter-rouge">__exit__</code>和<code class="language-plaintext highlighter-rouge">__enter__</code>方法的对象<li>对于open函数来说,一定要有as字句,以便获得文件的引用<li><code class="language-plaintext highlighter-rouge">__enter__</code>可以返回None,一般会返回上下文管理器的对象<li><code class="language-plaintext highlighter-rouge">__exit__</code>无论最后是否有异常,都会执行该函数<li><code class="language-plaintext highlighter-rouge">__exit__(exc_type, exc_value, traceback)</code><ul><li>exc_type:异常类<li>exc_value:异常实例,可以获取属性,使用exc_value.args<li>traceback:traceback对象<li>只有返回True时,证明异常已被处理,程序将继续执行,返回其他值时会向上冒泡</ul><li>自定义上下文管理器:<ul><li>使用<code class="language-plaintext highlighter-rouge">@contextlib.contextmanager</code><li>装饰器下函数的构成:</ul></ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="o">@</span><span class="n">contextlib</span><span class="p">.</span><span class="n">contextmanager</span>
	<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
		<span class="n">code</span><span class="p">(</span><span class="n">等同于enter</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">yield</span> <span class="p">(</span><span class="n">此处作为enter的返回值</span><span class="p">)</span>
		<span class="k">except</span> <span class="n">xxError</span><span class="p">:</span>
			<span class="n">code</span><span class="p">(</span><span class="n">等同于exit中的异常处理</span><span class="p">)</span>
		<span class="k">finally</span><span class="p">:</span>
			<span class="n">code</span><span class="p">(</span><span class="n">等同于exit的结束</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>IO方面的上下文管理器示例:</ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span>\<span class="n">filename</span><span class="p">,</span> <span class="n">access_mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">files</span> <span class="p">:</span>
		<span class="n">code</span> 
</pre></table></code></div></div><h2 id="协程">协程</h2><ul><li>单线程下的并发,又称微线程<li>优点:<ol><li>协程的切换开销更小,属于程序级别的切换,操作系统完全感知不到,因而更加轻量级<li>单线程内就可以实现并发的效果,最大限度的利用cpu</ol><li>缺点:<ol><li>协程的本质是单线程下,无法利用多核,可以是一个程序开启多个进程,每个进程内开启多个线程,每个线程内开启协程<li>协程指的是单个线程,因而一旦协程出现阻塞,那么整个线程都会阻塞</ol><li>协程生成器的基本行为:</ul><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
		<span class="n">code</span><span class="p">(</span><span class="n">yield前半部分</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">(</span><span class="n">协程在此处暂停</span><span class="p">,</span><span class="n">等待从用户处接收数据</span><span class="p">)</span>
		<span class="n">code</span><span class="p">(</span><span class="n">yield后半部分</span><span class="p">,</span><span class="n">接收数据后就会执行</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>使用的语句:<ul><li>先使用一个对象接收func<code class="language-plaintext highlighter-rouge">myCoro = func()</code><li>这时还没有开始执行,使用next执行<code class="language-plaintext highlighter-rouge">next(myCoro)</code>&lt;/br&gt;这一步又被称为预激(prime)协程<li>会执行到yield处,发送数据<code class="language-plaintext highlighter-rouge">myCoro.send(99)</code><li>继续执行,到达下一个yield处或是结尾,到达结尾抛出<code class="language-plaintext highlighter-rouge">StopIteration</code>异常<li>可以使用<code class="language-plaintext highlighter-rouge">inspect.getgeneratorstate(myCoro)</code>来获得协程的当前状态,该函数返回一个字符串<ul><li><code class="language-plaintext highlighter-rouge">GEN_CREATED</code>:协程等待执行<li><code class="language-plaintext highlighter-rouge">GEN_RUNNING</code>:解释器正在执行,仅多线程时有效<li><code class="language-plaintext highlighter-rouge">GEN_SUPENDED</code>:在yield表达式处暂停<li><code class="language-plaintext highlighter-rouge">GEN_CLOSED</code>:执行结束</ul><li>可以使用<code class="language-plaintext highlighter-rouge">myCoro.close()</code>来主动终止协程,注意协程也会被垃圾回收</ul><li>异常处理:<ul><li>当出现异常(如send一个错误的值),那么没有处理的情况下会抛出异常并终止协程<li>可以使用<code class="language-plaintext highlighter-rouge">generator.throw()</code>来抛出异常,处理后继续执行到下一个yield处</ul></ul><h2 id="进程与线程">进程与线程</h2><h3 id="多线程">多线程:</h3><ul><li>常用方法:<ul><li><code class="language-plaintext highlighter-rouge">t = threading.Thread(target = funcName, args = ())</code>:开启一个线程,执行函数funcName,传递参数args(元组)<li><code class="language-plaintext highlighter-rouge">t.start()</code>:开始执行线程<li><code class="language-plaintext highlighter-rouge">t.setName()</code>:设置线程名称<li><code class="language-plaintext highlighter-rouge">t.getName()</code>:获取线程名称<li><code class="language-plaintext highlighter-rouge">t.setDeamon(True)</code>:设置为守护线程,用于处理这种情况:主线程执行完毕,子线程在无限循环,子线程若被设置为守护线程,主线程就不必等待子线程执行完毕后再退出程序(注意在start前设置)<li><code class="language-plaintext highlighter-rouge">t.join()</code>:此线程执行完毕后,再执行主线程<li><code class="language-plaintext highlighter-rouge">threading.active_count()</code>:返回当前活跃的线程数,含主线程</ul></ul><h3 id="全局解释器锁gil">全局解释器锁(GIL)</h3><ul><li>全局解释器锁(Global Interpreter Lock),一个python的进程中仅一个<li>工作过程:<ol><li>拿到公共数据<li>申请GIL<li>python解释器调用os原生线程<li>os操作cpu执行运算<li>当该线程执行时间到后,无论运算是否已经执行完,GIL都被要求释放<li>进而由其他进程重复上面的过程<li>等其他进程执行完后,又会切换到之前的进程</ol></ul><h3 id="锁">锁</h3><h4 id="同步锁互斥锁">同步锁/互斥锁</h4><ul><li>同一时刻的一个进程下的一个线程只能使用一个CPU,要确保这个线程下的程序在一段时间内被CPU执行,就需要同步锁<li>需要先实例化对象:<code class="language-plaintext highlighter-rouge">r = threading.Lock()</code><li>获取锁:<code class="language-plaintext highlighter-rouge">r.acquire()</code><li>释放锁:<code class="language-plaintext highlighter-rouge">r.release()</code></ul><h4 id="递归锁">递归锁</h4><ul><li>支持嵌套,可以多重加锁<li>Rlock内部有一个Lock和Counter变量,每acquire一次,Counter+1,每release一次,Counter-1,当全部的Lock都被release,其他线程才能获得资源<li>用于处理死锁,死锁是指两个或两个以上的进程或线程在进行中,因争夺资源而造成的一种互相等待的现象</ul><h4 id="信号量semaphore">信号量(Semaphore)</h4><ul><li>同进程一样,semaphore管理一个内置计数器,每acquire一次内置函数-1,每release一次内置函数+1,计数器不能为0,否则会阻塞线程直至其他线程调用release<li>创建<code class="language-plaintext highlighter-rouge">mysf = threading.Semaphore(n)</code>&lt;/br&gt;n:计数器上限,最多可以同时锁的线程数量,默认为1,必须大于0<li>底层是Condition锁</ul><h4 id="事件event类">事件(Event类)</h4><ul><li>用于主线程控制其他子线程的执行,是一个简单的线程同步对象<li>内置一个flag变量,flag(标志位)为True时,wait()不阻塞,否则阻塞<li><code class="language-plaintext highlighter-rouge">e = threading.Event()</code>创建一个事件<li><code class="language-plaintext highlighter-rouge">e.set()</code>设置标志位True<li><code class="language-plaintext highlighter-rouge">e.clear()</code>设置标志位False<li><code class="language-plaintext highlighter-rouge">e.is_set()</code>判断是否设置了标志位<li><code class="language-plaintext highlighter-rouge">e.wait()</code>监听flag,若False则会一直阻塞</ul><h2 id="socket编程">Socket编程</h2><ul><li>socket也成为套接字,用于socket通信<li>创建socket对象:<code class="language-plaintext highlighter-rouge">socket(family, type, proto, fileno)</code><ul><li>family:地址簇,默认为AF_INET(使用IPV4)<ul><li>AF_UNIX:unix本机间通信<li>AF_INET6:使用IPV6</ul><li>type:类型,默认为SOCKET_STREAM(TCP套接字类型)<ul><li>SOCKET_DGREAM(UDP套接字类型)</ul><li>proto:协议号,默认为0<li>fileno:默认为None,若不为None,则从指定文件描述器获取其他三个的信息</ul><li>将socket绑定到指定地址:<code class="language-plaintext highlighter-rouge">socket.bind(address)</code><ul><li>address:双元素元组,(host,port)</ul><li>启用服务器以接受连接<code class="language-plaintext highlighter-rouge">socket.listen(backlog)</code><li>接受连接<code class="language-plaintext highlighter-rouge">socket.accept()</code><ul><li>返回一个双元素元组,(conn,address)<li>conn:socket对象,可以在该连接上发送和接受数据<li>address:另一端的地址<li>服务端方法</ul><li>连接到远程socket<code class="language-plaintext highlighter-rouge">socket.connect(address)</code><ul><li>客户端方法<li>连接信号中断,会等待并阻塞,直至重新连接或超时;非阻塞套接字,则连接信号中断会引发<code class="language-plaintext highlighter-rouge">InterruptedError</code>异常</ul><li>发送数据:<code class="language-plaintext highlighter-rouge">socket.send(data, flags)</code><ul><li>发送数据类型是bytes</ul><li>接收数据:<code class="language-plaintext highlighter-rouge">socket.recv(bufsize, flags)</code><ul><li>bufsize:一次性接收的最大数据量</ul><li>关闭连接:<code class="language-plaintext highlighter-rouge">socket.close()</code><ul><li>关闭后,连接断开</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/python/'>Python</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python/" class="post-tag no-text-decoration" >python</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" class="post-tag no-text-decoration" >基础</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Python知识点总结目录 - voidblank&url=https://voidblank.github.io/posts/python/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Python知识点总结目录 - voidblank&u=https://voidblank.github.io/posts/python/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Python知识点总结目录 - voidblank&url=https://voidblank.github.io/posts/python/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vuex/">Vuex</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><li><a href="/posts/spring-boot-%E6%B3%A8%E8%A7%A3/">SpringBoot 注解</a><li><a href="/posts/enable-google-pv/">Enable Google Page Views</a><li><a href="/posts/abstract-queued-synchronizer/">AQS</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/JavaScript/"><div class="card-body"> <span class="timeago small" > Apr 18 <i class="unloaded">2021-04-18T14:03:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JavaScript</h3><div class="text-muted small"><p> JavaScript 输出 window.alert()：弹出警告框 document.write()内容输出到html文档中 如果在html加载完成后执行该函数，则会使html内容被覆盖 document.getElementById("demo").innerHTML:将id=demo的内容改写 console.log()：输出到...</p></div></div></a></div><div class="card"> <a href="/posts/css/"><div class="card-body"> <span class="timeago small" > May 16 <i class="unloaded">2021-05-16T13:59:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CSS基础</h3><div class="text-muted small"><p> CSS 语法 {}内为k-v对，使用分号分割 注释:/* */ 基本 1 2 3 4 p { color: blue; front-size: 12px; } p表示指示器 ID选择器 1 2 3 4 5 #param1 { color: blue; front-size: 12px; } 使用#开始的，表示i...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><div class="card-body"> <span class="timeago small" > Apr 10 <i class="unloaded">2021-04-10T16:42:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构与算法</h3><div class="text-muted small"><p> 数据结构与算法 线性表 线性结构,头节点无前驱有一个后继,尾节点无后继有一个前驱。 只能顺序查找,查找时间复杂度O(n),删除时间复杂度O(1) 数组 顺序存储,连续存储,方便查找,可以随机查找元素,删除和插入较慢。 多维数组不是线性表 插入:时间复杂度O(n) 删除:时间复杂度O(n) 查找:时间复杂度O(n) 线性链表 链式存储结构,可以不...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/redis/" class="btn btn-outline-primary" prompt="Older"><p>Redis基础</p></a> <a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="btn btn-outline-primary" prompt="Newer"><p>数据结构与算法</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">voidblank</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://voidblank.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
