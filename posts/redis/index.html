<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Redis基础" /><meta name="author" content="voidblank" /><meta property="og:locale" content="en_US" /><meta name="description" content="Redis" /><meta property="og:description" content="Redis" /><link rel="canonical" href="https://voidblank.github.io/posts/redis/" /><meta property="og:url" content="https://voidblank.github.io/posts/redis/" /><meta property="og:site_name" content="voidblank" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-10T15:28:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Redis基础" /><meta name="twitter:site" content="@voidblank" /><meta name="twitter:creator" content="@voidblank" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"voidblank"},"description":"Redis","headline":"Redis基础","dateModified":"2021-04-11T15:15:40+08:00","url":"https://voidblank.github.io/posts/redis/","datePublished":"2021-04-10T15:28:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://voidblank.github.io/posts/redis/"},"@context":"https://schema.org"}</script><title>Redis基础 | voidblank</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://imgur.com/oEa1xeJ.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">voidblank</a></div><div class="site-subtitle font-italic">just a blog!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/voidblank" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/voidblank" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['cy1245171920','outlook.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Redis基础</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Redis基础</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> voidblank </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 10, 2021, 3:28 PM +0800" prep="on" > Apr 10 <i class="unloaded">2021-04-10T15:28:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 11, 2021, 3:15 PM +0800" prefix="Updated " > Apr 11 <i class="unloaded">2021-04-11T15:15:40+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9064 words">50 min</span></div></div><div class="post-content"><h1 id="redis">Redis</h1><h2 id="指令">指令</h2><h3 id="启动">启动</h3><ul><li>启动本地: <code class="language-plaintext highlighter-rouge">&gt;redis-cli</code><li>启动远程: <code class="language-plaintext highlighter-rouge">&gt;redis-cli -h host -p port -a pswd</code></ul><h3 id="key">Key</h3><ul><li>设置: <code class="language-plaintext highlighter-rouge">SET key value</code><li>获取: <code class="language-plaintext highlighter-rouge">GET key</code><ul><li>如果没有值,返回空</ul><li>删除: <code class="language-plaintext highlighter-rouge">DEL key</code><ul><li>成功返回1,失败返回0</ul><li>检查是否存在: <code class="language-plaintext highlighter-rouge">EXISTS key</code><ul><li>存在返回1,否则0</ul><li>设置过期时间(s): <code class="language-plaintext highlighter-rouge">EXPIRE key seconds</code><ul><li>成功返回1,key不存在或更新时间(2.1.3及以下版本)返回0</ul><li>设置过期时间(unix时间戳): <code class="language-plaintext highlighter-rouge">EXPIREAT key timestamp</code><li>设置过期时间(ms): <code class="language-plaintext highlighter-rouge">PEXPIRE key milliseconds</code><li>设置过期时间(unix ms): <code class="language-plaintext highlighter-rouge">PEXPIREAT key milliseconds-timestamp</code><li>获取满足pattern的key的array: <code class="language-plaintext highlighter-rouge">KEYS PATTERN</code><ul><li><code class="language-plaintext highlighter-rouge">&gt;KEYS a*</code> 获取所有a开头的key<li><code class="language-plaintext highlighter-rouge">&gt;KEYS *</code> 获取所有key</ul><li>移除key的过期时间: <code class="language-plaintext highlighter-rouge">PERSIST key</code><ul><li>成功返回1,key不存在或未设置时间返回0</ul><li>获取key的剩余生命周期(ms): <code class="language-plaintext highlighter-rouge">PTTL key</code><ul><li>若存在生命周期,则返回时间;若无生命周期,则返回-1;若无该key,返回-2<li>2.8及以下版本,只会返回-1或时间</ul><li>获取key的剩余生命周期(s): <code class="language-plaintext highlighter-rouge">TTL key</code><li>获取一个随机key: <code class="language-plaintext highlighter-rouge">RANDOMKEY</code><ul><li>数据为空时,返回null</ul><li>将旧的key重命名: <code class="language-plaintext highlighter-rouge">RENAME oldName newName</code><ul><li>如果newName已存在,会被覆盖<li>如果oldName不存在或name相同,则返回一个error</ul><li>将旧的key重命名: <code class="language-plaintext highlighter-rouge">RENAMEX oldName newName</code><ul><li>仅当newName不存在时,重命名<li>成功返回1,失败返回0</ul><li>获取key的类型: <code class="language-plaintext highlighter-rouge">TYPE key</code><ul><li>若不存在,返回none</ul></ul><h4 id="遍历迭代">遍历迭代</h4><ul><li>keys: <code class="language-plaintext highlighter-rouge">KEYS pattern</code> 返回数据库内满足pattern的所有key<li>scan: <code class="language-plaintext highlighter-rouge">SCAN cursor [MATCH pattern] [COUNT count]</code><ul><li>cursor: 游标,默认为0<li>MATCH: 正则匹配<li>COUNT: 返回的最大数量,默认为10<li>如果设定了COUNT导致没有返回全部,则会返回一个非0游标,可以使用该游标进行后续的遍历</ul><li>sscan: <code class="language-plaintext highlighter-rouge">SSCAN key cursor [MATCH pattern] [COUNT count]</code><ul><li><div class="table-wrapper"><table><tbody><tr><td>迭代指定Set集合的元素<td>key</table></div></ul><li>hscan: <code class="language-plaintext highlighter-rouge">HSCAN key cursor [MATCH pattern] [COUNT count]</code><ul><li>迭代hash的键值对,奇数为key,偶数为value</ul><li>zscan: <code class="language-plaintext highlighter-rouge">ZSCAN key cursor [MATCH pattern] [COUNT count]</code><ul><li>迭代有序集合的元素</ul></ul><h2 id="数据类型">数据类型</h2><h3 id="string">String</h3><ul><li>通过key获取value,独立的k-v</ul><h4 id="getrange">GETRANGE</h4><ul><li><code class="language-plaintext highlighter-rouge">GETRANGE key start end</code><li>获取子串<li>start &gt;= 0 &amp;&amp; end &gt;= 0: 获取start-end的子串<li>start &gt;= 0 &amp;&amp; end &lt; 0 : 获取从strat开始,到倒数第end个<li>start &lt; 0 &amp;&amp; end &lt; 0 &amp;&amp; start &lt; end: 获取从倒数start-end的子串<ul><li>如, start = -3, end = -1, 则获取倒数3-倒数1的子串,顺序为正向</ul><li>如果超过范围,多余的部分为空,会被省略<li>其他情况下均为非法值,返回空<li>注意:中文占2位</ul><h4 id="setrange">SETRANGE</h4><ul><li><code class="language-plaintext highlighter-rouge">SETRANGE key offset value</code><li>从offset开始,使用value覆盖原值</ul><h4 id="getset">GETSET</h4><ul><li><code class="language-plaintext highlighter-rouge">GETSET key newValue</code><li>将key的值更新,返回旧值<li>如果旧值不存在(例如key不存在),则返回nil/null<li>当key不是String时,返回error</ul><h4 id="getbit">GETBIT</h4><ul><li><code class="language-plaintext highlighter-rouge">GETBIT key offset</code><li>获取value的第offset位的位(bit)<li>若超过限制或key不存在,返回0<li>时间复杂度:O(1)</ul><h4 id="setbit">SETBIT</h4><ul><li><code class="language-plaintext highlighter-rouge">SETBIT key offset value</code><li><div class="table-wrapper"><table><tbody><tr><td>设置key的value值,第offset位的值为0<td>1</table></div><li>如果值错误,返回error<li>时间复杂度:O(1)</ul><h4 id="bitcount">BITCOUNT</h4><ul><li><code class="language-plaintext highlighter-rouge">BITCOUNT key</code><li>获取key的value值中值为1的二进制位的数量<li>时间复杂度:O(n)</ul><h4 id="bitop">BITOP</h4><ul><li><code class="language-plaintext highlighter-rouge">BITOP operation resultKey [key...]</code><li>对多个位数组进行逻辑操作<li>operation: 逻辑操作,包括<code class="language-plaintext highlighter-rouge">and</code>,<code class="language-plaintext highlighter-rouge">or</code>,<code class="language-plaintext highlighter-rouge">xor</code><li>resultKey: 最后的结果存储<li>[key…]: 要运算的key的数组</ul><h4 id="setex">SETEX</h4><ul><li><code class="language-plaintext highlighter-rouge">SETEX KEY_NAME TIMEOUT VALUE</code><li>为key设置值及过期时间(s)<li>会覆盖旧值</ul><h4 id="setnx">SETNX</h4><ul><li><code class="language-plaintext highlighter-rouge">SETNX key value</code><li>当该key不存在时,设置value<li>成功返回1,失败返回0</ul><h4 id="strlen">STRLEN</h4><ul><li><code class="language-plaintext highlighter-rouge">STRLEN key</code><li>返回值的长度<li>不存在则返回0</ul><h4 id="incr">INCR</h4><ul><li><code class="language-plaintext highlighter-rouge">INCR key</code><li>使值加1<li>若key不存在,则初始化key为0,再进行增加操作<li>如果值是错误类型或不能表示为数字,则返回error<li>值限制在64位有符号数字之内</ul><h4 id="incrby">INCRBY</h4><ul><li><code class="language-plaintext highlighter-rouge">INCRBY key value</code><li>使值增加value<li>其他同INCR</ul><h4 id="incrbyfloat">INCRBYFLOAT</h4><ul><li><code class="language-plaintext highlighter-rouge">INCRBYFLOAT key value</code><li>使值增加value(浮点数)<li>仅会保留第一位的0,多余的0会被删除</ul><h4 id="decr">DECR</h4><ul><li><code class="language-plaintext highlighter-rouge">DECR key</code><li>使值减1<li>其他同INCR</ul><h4 id="decrby">DECRBY</h4><ul><li><code class="language-plaintext highlighter-rouge">DECRBY key value</code><li>使值减少value<li>其他同INCR</ul><h4 id="append">APPEND</h4><ul><li><code class="language-plaintext highlighter-rouge">APPEND key value</code><li>将value字符串加到指定值的后面<li>如果key不存在,则等价于SET<li>返回当前字符串的长度</ul><h3 id="hash">Hash</h3><ul><li>存储map形k-v对</ul><h4 id="hset">HSET</h4><ul><li><code class="language-plaintext highlighter-rouge">HSET key field value</code><li>在key中设置一个field-value对<li>如果key对应的值不是hash,则新建一个<li>如果field已存在,则覆盖<li>field已存在返回0,否则返回1</ul><h4 id="hmset">HMSET</h4><ul><li><code class="language-plaintext highlighter-rouge">HMSET key field value [field value...]</code><li>新建一个hash,并为其设置初始值<li>会直接覆盖旧hash<li>若key不是hash,则返回一个error<li>可以一次性设置多个值</ul><h4 id="hsetnx">HSETNX</h4><ul><li><code class="language-plaintext highlighter-rouge">HSETNX key field value</code><li>设置一个field-value对,仅当field不存在时<li>成功返回1,失败返回0</ul><h4 id="hget">HGET</h4><ul><li><code class="language-plaintext highlighter-rouge">HGET key field</code><li>获取hash中指定field的值<li>不存在则返回nil</ul><h4 id="hmget">HMGET</h4><ul><li><code class="language-plaintext highlighter-rouge">HMGET key field [field...]</code><li>获取hash中指定field的值,可多个<li>不存在返回nil</ul><h4 id="hgetall">HGETALL</h4><ul><li><code class="language-plaintext highlighter-rouge">HGETALL key</code><li>返回key对应的hash的所有field-value对<li>顺序为:field1,value1,field2,value2<li>所以返回的列表的长度是hash长度的二倍<li>若key不存在,则返回空列表</ul><h4 id="hexists">HEXISTS</h4><ul><li><code class="language-plaintext highlighter-rouge">HEXISTS key field</code><li>判断key对应的hash中是否存在指定field<li>存在返回1,不存在或key不存在返回0</ul><h4 id="hdel">HDEL</h4><ul><li><code class="language-plaintext highlighter-rouge">HDEL key field [field...]</code><li>删除指定field<li>返回删除成功的个数</ul><h4 id="hlen">HLEN</h4><ul><li><code class="language-plaintext highlighter-rouge">HLEN key</code><li>返回指定hash中field的数量<li>key不存在时返回0</ul><h4 id="hvals">HVALS</h4><ul><li><code class="language-plaintext highlighter-rouge">HVALS key</code><li>返回指定hash中的所有的value<li>key不存在时返回空列表</ul><h4 id="hkeys">HKEYS</h4><ul><li><code class="language-plaintext highlighter-rouge">HKEYS key</code><li>返回指定hash中的所有的field<li>key不存在时返回空列表</ul><h3 id="list">List</h3><ul><li>列表,队列</ul><h4 id="lpush">LPUSH</h4><ul><li><code class="language-plaintext highlighter-rouge">LPUSH key value [value...]</code><li>将value插入到指定list的头部<li>插入多个值时,按从左到右的顺序向头部插入,所以最后一个值会变为头部值<li>如果不存在key则创建<li>如果key类型不是list,则返回error<li>返回当前列表长度</ul><h4 id="lpushx">LPUSHX</h4><ul><li><code class="language-plaintext highlighter-rouge">LPUSHX key value</code><li>将value插入到指定list的头部<li>只允许一个值,而且key必须存在<li>成功返回1,失败返回0</ul><h4 id="rpush">RPUSH</h4><ul><li><code class="language-plaintext highlighter-rouge">RPUSH key value [value...]</code><li>将多个值插入到list的尾部<li>同LPUSH</ul><h4 id="rpushx">RPUSHX</h4><ul><li><code class="language-plaintext highlighter-rouge">RPUSHX key value</code><li>将value插入到指定list的尾部<li>同LPUSHX</ul><h4 id="lset">LSET</h4><ul><li><code class="language-plaintext highlighter-rouge">LSET key index value</code><li>将value插入到list的index位置<li>会将原位置的值覆盖<li>若超出范围/空列表/不存在key/类型错误,则返回error</ul><h4 id="linsert">LINSERT</h4><ul><li><code class="language-plaintext highlighter-rouge">LINSERT key BEFORE|AFTER pivot value</code><li><div class="table-wrapper"><table><tbody><tr><td>将value值插入到key对应的list中pivot值的前面<td>后面</table></div><li>插入操作,不会覆盖原位置的值<li>成功返回当前列表长度<li>没找到指定元素则返回-1<li>key不存在或空列表,返回0</ul><h4 id="lpop">LPOP</h4><ul><li><code class="language-plaintext highlighter-rouge">LPOP key</code><li>移除列表的第一个元素,返回该元素<li>key不存在返回nil</ul><h4 id="rpop">RPOP</h4><ul><li><code class="language-plaintext highlighter-rouge">RPOP key</code><li>移除列表的最后一个元素,返回该元素<li>key不存在时返回nil</ul><h4 id="rpoplpush">RPOPLPUSH</h4><ul><li><code class="language-plaintext highlighter-rouge">RPOPLPUSH fromkey tokey</code><li>将fromkey列表的最后一个元素弹出并放置在tokey的头部<li>返回操作的元素</ul><h4 id="lrem">LREM</h4><ul><li><code class="language-plaintext highlighter-rouge">LREM key count value</code><li>移除列表中和value相等的元素,其中:<ul><li>count &gt; 0,正向移除count个元素<li><div class="table-wrapper"><table><tbody><tr><td>count &lt; 0,反向移除<td>count<td>个元素</table></div><li>count = 0,移除全部元素</ul><li>返回移除的元素数量<li>key不存在时返回0</ul><h4 id="ltrim">LTRIM</h4><ul><li><code class="language-plaintext highlighter-rouge">LTRIM key start end</code><li>保留列表从start到end的元素,可以为负数表示倒数<li></ul><h4 id="lindex">LINDEX</h4><ul><li><code class="language-plaintext highlighter-rouge">LINDEX key index</code><li>查询第index位置上的元素<li>可以使用负数,表示倒数<li>若超过范围返回nil</ul><h4 id="lrange">LRANGE</h4><ul><li><code class="language-plaintext highlighter-rouge">LRANGE key start end</code><li>返回列表从start到end的值<li>可以为负,表示倒数第几个</ul><h4 id="llen">LLEN</h4><ul><li><code class="language-plaintext highlighter-rouge">LLEN key</code><li>返回列表长度<li>不存在key返回0,错误类型返回error</ul><h4 id="blpop">BLPOP</h4><ul><li><code class="language-plaintext highlighter-rouge">BLPOP key [key...] timeout</code><li>将指定列表的第一个元素移除并返回列表的key,移除元素及操作执行的时间,根据timeout设置该操作的时间上限<li>如果没有元素可以弹出会阻塞,超时会返回nil</ul><h4 id="brpop">BRPOP</h4><ul><li><code class="language-plaintext highlighter-rouge">BRPOP key [key...] timeout</code><li>将指定列表的最后一个元素移除并返回列表的key,移除元素及操作执行的时间,根据timeout设置该操作的时间上限<li>如果没有元素可以弹出会阻塞,超时返回nil</ul><h4 id="brpoplpush">BRPOPLPUSH</h4><ul><li><code class="language-plaintext highlighter-rouge">BRPOPLPUSH fromkey tokey timeout</code><li>将fromkey列表的最后一个元素弹出并放置在tokey的头部,最多阻塞timeout秒<li>成功返回操作的元素及处理时间,超时返回nil及处理时间</ul><h3 id="set">Set</h3><ul><li>无序集合,hash实现</ul><h4 id="sadd">SADD</h4><ul><li><code class="language-plaintext highlighter-rouge">SADD key value [value...]</code><li>向集合中添加元素,返回添加数量<li>如果类型错误返回error</ul><h4 id="spop">SPOP</h4><ul><li><code class="language-plaintext highlighter-rouge">SPOP key</code><li>集合中随机移除一个元素,返回该元素<li>若为空则返回nil</ul><h4 id="srem">SREM</h4><ul><li><code class="language-plaintext highlighter-rouge">SREM key value [value...]</code><li>移除集合中的指定元素,返回移除成功的数量<li>如果元素不存在,则忽略</ul><h4 id="sismember">SISMEMBER</h4><ul><li><code class="language-plaintext highlighter-rouge">SISMEMBER key value</code><li>判断value是否在集合中,存在返回1,不存在或key不存在返回0</ul><h4 id="smove">SMOVE</h4><ul><li><code class="language-plaintext highlighter-rouge">SMOVE fromkey tokey value</code><li>将value从fromkey集合移动到tokey集合中<li>原子操作,成功返回1,失败返回0</ul><h4 id="scard">SCARD</h4><ul><li><code class="language-plaintext highlighter-rouge">SCARD key</code><li>返回集合中元素的数量<li>key不存在时返回0</ul><h4 id="sdiff">SDIFF</h4><ul><li><code class="language-plaintext highlighter-rouge">SDIFF key [key...]</code><li>返回key中独有的元素(差集)<li>key若不存在视为空集</ul><h4 id="sdiffstore">SDIFFSTORE</h4><ul><li><code class="language-plaintext highlighter-rouge">SDIFFSTORE key key1 [key...]</code><li>将key1中独有的元素存放到key中,返回key中元素的数量(差集)<li>该方法会将key清空后重新放置,所以也可以认为返回值为操作的元素的数量</ul><h4 id="sinter">SINTER</h4><ul><li><code class="language-plaintext highlighter-rouge">SINTER key [key...]</code><li>返回key中共有的元素(交集)<li>不存在的key认作空集,有空集时返回空集</ul><h4 id="sinterstore">SINTERSTORE</h4><ul><li><code class="language-plaintext highlighter-rouge">SINTERSTORE key key1 [key...]</code><li>将key1中共有的元素放置到key中,返回key中元素的数量(交集)</ul><h4 id="sunion">SUNION</h4><ul><li><code class="language-plaintext highlighter-rouge">SUNION key [key...]</code><li>返回key及其他集合的并集<li>不存在的key视作空集</ul><h4 id="sunionstore">SUNIONSTORE</h4><ul><li><code class="language-plaintext highlighter-rouge">SUNIONSTORE key key1 [key...]</code><li>将key1及其他集合的并集赋给key,返回key中元素的数量(并集)<li>不存在的key视作空集</ul><h4 id="smembers">SMEMBERS</h4><ul><li><code class="language-plaintext highlighter-rouge">SMEMBERS key</code><li>返回对应key集合的所有keys</ul><h4 id="srandmember">SRANDMEMBER</h4><ul><li><code class="language-plaintext highlighter-rouge">SRANDMEMBER key [count]</code><li>返回key集合中随机的count个值,默认为10</ul><h3 id="sorted-set">Sorted Set</h3><ul><li>有序的集合,通过为value关联一个double类型的score来进行排序<li>相同的value,后添加的会覆盖先添加的<li>底层实现:<ul><li>[score, value]键值对数量少于128个且每个元素长度小于64字节,则为ziplist<li>否则使用跳表(skiplist)存储value,同时有一个hash用来映射从value到score</ul></ul><h4 id="zadd">ZADD</h4><ul><li><code class="language-plaintext highlighter-rouge">ZADD key [NX|XX] [CH] [INCR] score value [score... value...]</code><li>为指定zset添加成员,并设定其分数和value<li>默认返回添加的成员的数量<li>参数:<ul><li>NX: 不更新存在的成员,仅添加成员<li>XX: 更新存在的成员,不添加成员<li>CH: 更改返回值,返回修改的成员的数量<li>INCR: 返回被操作的成员的score。如果添加了新成员,则设置新成员的值为score;如果是对旧成员的更新,那么会对旧成员在原有score的基础上增加score的操作;启用该参数时,只有对一对成员进行操作</ul><li>允许inf及-inf</ul><h4 id="zrem">ZREM</h4><ul><li><code class="language-plaintext highlighter-rouge">ZREM key value [value...]</code><li>移除指定zset中的指定value,返回移除成功的个数<li>不存在的会被忽略,key不是zset会返回error</ul><h4 id="zremrangebyrank">ZREMRANGEBYRANK</h4><ul><li><code class="language-plaintext highlighter-rouge">ZREMRANGEBYRANK key start stop</code><li>将start到stop的值都删除,返回被移除的个数<li>start与stop可以为负,表示倒数<li>start与stop表示下标,从0开始</ul><h4 id="zremrangebyscore">ZREMRANGEBYSCORE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZREMRANGEBYSCORE key min max</code><li>将score在min到max间的值都删除,返回被移除的个数</ul><h4 id="zincrby">ZINCRBY</h4><ul><li><code class="language-plaintext highlighter-rouge">ZINCRBY key increment value</code><li>将指定value增加increment,返回value当前的分数值<li>可以传入一个负的increment表示减少,支持整数和浮点数<li>如果key不存在或value不存在,相当于zadd</ul><h4 id="zcard">ZCARD</h4><ul><li><code class="language-plaintext highlighter-rouge">ZCARD key</code><li>返回zset的size<li>如果key不存在,返回0</ul><h4 id="zcount">ZCOUNT</h4><ul><li><code class="language-plaintext highlighter-rouge">ZCOUNT key min max</code><li>返回score在min到max间的成员数量</ul><h4 id="zrange">ZRANGE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZRANGE key start stop [WITHSCORES]</code><li>返回指定zset中下标从start到stop的value,从小到大的顺序<li>如果设置了WITHSCORES参数,则还会返回value的key<li>可以设置负数表示倒数<li>如果start大于size或start大于stop,则返回nil<li>如果stop大于size,则按stop计算</ul><h4 id="zrevrange">ZREVRANGE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZREVRANGE key start stop [WITHSCORES]</code><li>ZRANGE的倒序,其他相同</ul><h4 id="zrank">ZRANK</h4><ul><li><code class="language-plaintext highlighter-rouge">ZRANK key value</code><li>返回value的下标,如果不存在返回nil</ul><h4 id="zrevrank">ZREVRANK</h4><ul><li><code class="language-plaintext highlighter-rouge">ZREVRANK key value</code><li>返回倒序的value下标,如果不存在返回nil</ul><h4 id="zscore">ZSCORE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZSCORE key value</code><li>返回指定value的score,若不存在返回nil<li>返回值是String</ul><h4 id="zrangebyscore">ZRANGEBYSCORE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code><li>返回指定zset中,score在min到max间的值<li>可以通过设置WITHSCORES返回score与value<li>可以通过设置LIMIT offset count来返回指定范围与个数,但是如果offset比较大时,可能会遍历全部导致O(n)时间复杂度<li>可以通过设置<code class="language-plaintext highlighter-rouge">(min</code>与<code class="language-plaintext highlighter-rouge">[min</code>来设置取值范围的开闭区间,默认为闭区间</ul><h4 id="zrangebylex">ZRANGEBYLEX</h4><ul><li><code class="language-plaintext highlighter-rouge">ZRANGEBYLEX key min max [LIMIT offset count]</code><li>返回指定zset中,value在min到max间的值<li>如果范围是字符串,那么:<ul><li>对于范围的字符串start~end,就会去查找首个满足String &gt;= start的字符串,接着找到首个 end &lt; String的字符串<li>https://blog.csdn.net/yidou120/article/details/90145911</ul></ul><h4 id="zunionstore">ZUNIONSTORE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code><li>将多个指定的zset中的key,按照给定的规则取并集,放到destination集合中,返回destination集合中元素的个数<li>numkeys表示key的个数,要与后面一致<ul><li>numkeys最小为1,超限会返回error<li>numkeys与后面的key数量不同会返回error</ul><li>WEIGHTS: 乘法因子,所有的集合的score都会在放入destination前乘该值,默认为1<li>AGGREGATE: 取并集的聚合方式,默认为SUM<ul><li>SUM: 将集合中相同的元素的score相加放入destination中<li>MIN: 取集合中score的最小值<li>MAX: 取集合中score的最大值</ul><li>会将destination集合进行重写</ul><h4 id="zinterstore">ZINTERSTORE</h4><ul><li><code class="language-plaintext highlighter-rouge">ZITNTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code><li>将多个指定的zset中的key,按照给定的规则取交集,放到destination集合中,返回destination集合中元素的个数<li>与ZUNIONSTORE相同</ul><h3 id="hyperloglog">HyperLogLog</h3><ul><li>不存储内部元素是什么,而是存储元素的基数<li>类似于一个用于统计Set集合中元素个数的结构,优点是在输入元素的数量是巨大时依旧可以保持小而固定的空间,优于集合</ul><h4 id="pfadd">PFADD</h4><ul><li><code class="language-plaintext highlighter-rouge">PFADD key value [value...]</code><li>向指定HyperLogLog中存储value<li>返回存储的个数,重复的元素会被忽略</ul><h4 id="pfcount">PFCOUNT</h4><ul><li><code class="language-plaintext highlighter-rouge">PFCOUNT key [key...]</code><li>返回指定HyperLogLog的元素个数</ul><h4 id="pfmerge">PFMERGE</h4><ul><li><code class="language-plaintext highlighter-rouge">PFMERGE endkey key1 [key...]</code><li>将多个HyperLogLog合并为endkey</ul><h2 id="订阅">订阅</h2><ul><li>多个客户端订阅频道,当频道发送信息时所有的客户端都会受到message</ul><h3 id="subscribe">SUBSCRIBE</h3><ul><li><code class="language-plaintext highlighter-rouge">SUBSCRIBE channel [channel...]</code><li>订阅多个指定的频道<li>每次返回3个值,分别是:<ul><li>返回值类型,包括:<code class="language-plaintext highlighter-rouge">subscribe</code>,<code class="language-plaintext highlighter-rouge">message</code>,<code class="language-plaintext highlighter-rouge">unsubscribe</code><li>如果返回值类型为subscribe,则表示订阅的频道名;如果返回值类型为message,则表示发送消息的频道名;如果返回值类型为ubsubscribe,则表示取消订阅的频道名<li><div class="table-wrapper"><table><tbody><tr><td>如果返回值类型为subscribe<td>unsubscribe,则表示当前订阅的频道个数;如果返回值类型为message,则表示频道发送的信息;</table></div></ul></ul><h3 id="unsubcribe">UNSUBCRIBE</h3><ul><li><code class="language-plaintext highlighter-rouge">UNSUBSCRIBE channel [channel...]</code><li>取消订阅指定频道<li>返回3个值,为:<ul><li>返回值类型:<code class="language-plaintext highlighter-rouge">unsubscribe</code><li>取消订阅的频道名<li>当前订阅的频道个数</ul></ul><h3 id="psubscribe">PSUBSCRIBE</h3><ul><li><code class="language-plaintext highlighter-rouge">PSUBSCRIBE pattern [pattern...]</code><li>按指定的正则匹配频道名进行订阅</ul><h3 id="punsubscribe">PUNSUBSCRIBE</h3><ul><li><code class="language-plaintext highlighter-rouge">PUNSUBSCRIBE pattern [pattern...]</code><li>按指定的正则匹配频道名进行取消订阅</ul><h3 id="publish">PUBLISH</h3><ul><li><code class="language-plaintext highlighter-rouge">PUBLISH channel message</code><li>作为指定的channel,发送message<li>返回接收到消息的订阅者的数量</ul><h3 id="pubsub">PUBSUB</h3><ul><li><code class="language-plaintext highlighter-rouge">PUBSUB subcommand argument [argument...]</code><li>有三种指令方式<li><code class="language-plaintext highlighter-rouge">PUBSUB CHANNELS [pattern]</code><ul><li>返回订阅数不为0的频道<li>如果不指定pattern,则返回全部;否则返回匹配pattern的频道</ul><li><code class="language-plaintext highlighter-rouge">PUBSUB NUMSUB [channel1...channeln]</code><ul><li>返回指定频道的名称与订阅者数量,无订阅者返回0</ul><li><code class="language-plaintext highlighter-rouge">PUBSUB NUMPAT</code><ul><li>返回订阅模式的数量(基于pattern的订阅)<li>每有一个正则匹配则算做1个</ul></ul><h2 id="事务">事务</h2><ul><li>事务是一个单独的隔离化操作<li>redis中的事务不支持回滚,即当事务的执行中出现错误时,会继续执行后续指令,而不会回滚操作<li>当事务的入队操作出现错误时,会返回一个error,同时该入队操作失败</ul><h3 id="事务中的命令">事务中的命令</h3><ul><li>MULTI<ul><li>标志事务的开始<li>返回ok</ul><li>EXEC<ul><li>表示事务的结束<li>会立刻开始执行该事务<li>如果操作被打断,返回nil</ul><li>DISCARD<ul><li>在使用MULTI指令开启事务后,使用该指令会取消事务</ul><li>WATCH<ul><li><code class="language-plaintext highlighter-rouge">WATCH key [key...]</code><li>监视一个或多个键,若他们发生变化,则事务不会被执行<li>当EXEC执行时,会自动解除监视<li>如果因为键变化导致事务被打断,EXEC操作会返回nil<li>如果WATCH了一个有生命周期的键,那么即使这个键过期了,也依然可以执行事务</ul><li>UNWATCH<ul><li><code class="language-plaintext highlighter-rouge">UNWATCH [key...]</code><li>解除一个或多个键的监视<li>如果无参数,则解除所有监视</ul></ul><h2 id="服务器命令">服务器命令</h2><ul><li>用于管理Redis服务</ul><h3 id="bgsave">BGSAVE</h3><ul><li>异步保存当前数据库的数据到磁盘<li>Redis主进程会fork一个子进程执行保存操作,而父进程会继续处理客户端请求<li>立刻返回OK</ul><h3 id="bgrewriteaof">BGREWRITEAOF</h3><ul><li>用于异步执行AOF文件重写操作<li>即使执行失败,也不会有任何数据丢失,因为在AOF重写完成前旧的AOF文件不会有任何修改<li>ver2.4之后,AOF重写由Redis自动触发,但也可以通过该命令手动触发</ul><h2 id="结构存储">结构存储</h2><ul><li>redis常用的数据类型都通过一个<code class="language-plaintext highlighter-rouge">redisObject</code>的对象进行存储的,包含以下结构:<div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">encoding</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">lru</span><span class="o">:</span><span class="n">LRU_BITS</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</pre></table></code></div></div><li>一个redisObject的大小:4bit + 4bit + 24bit + 4 byte + 9 byte = 16byte</ul><h3 id="type">type</h3><ul><li>表示对象的类型,占4bit<li>REDIS_STRING 0 字符串<li>REDIS_LIST 1 列表<li>REDIS_SET 2 集合<li>REDIS_ZSET 3 有序集<li>REDIS_HASH 4 哈希表</ul><h3 id="encoding">encoding</h3><ul><li>表示对象的内部编码,占4bit<li><code class="language-plaintext highlighter-rouge">object encoding [key]</code>:可以查看对应的encoding<div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#define REDIS_ENCODING_RAW 0    // 编码为字符串
#define REDIS_ENCODING_INT 1    // 编码为整数
#define REDIS_ENCODING_HT 2     // 编码为哈希表
#define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap(2.6 后不再使用)
#define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表
#define REDIS_ENCODING_ZIPLIST 5    // 编码为压缩列表
#define REDIS_ENCODING_INTSET 6     // 编码为整数集合
#define REDIS_ENCODING_SKIPLIST 7    // 编码为跳跃表
</span></pre></table></code></div></div></ul><h3 id="ptr">ptr</h3><ul><li>指针,指向具体的数据</ul><h3 id="lru">lru</h3><ul><li>记录对象最后一次被命令程序访问的时间,ver2.6占22bit,ver4.0占24bit<li>通过对比lru时间与当前时间可以获得对象的空转时间<li><code class="language-plaintext highlighter-rouge">object idletime [key]</code>:显示指定key的空转时间,单位为秒,不会改变对象的lru值</ul><h3 id="refcount">refcount</h3><ul><li>记录对象被引用的次数,整型,用于对象的引用计数与gc<li>对象创建时设为1<ul><li>每当新程序使用该对象时,refcount++<li>当该对象不再被一个新程序使用时,refcount–<li>refcount为0时,触发gc</ul><li>被多次使用的对象被称为共享对象(即refcount&gt;1),仅支持整数值的字符串对象<ul><li>原因:共享对象虽然会降低内存消耗,但是判断两个对象是否相等却需要耗费额外的时间,整数值的判断操作时间复杂度为O(1),字符串为O(n),哈希、列表、集合、有序集为O(n<sup>2</sup>)</ul><li>redis服务器初始化时,会创建0~9999整数值(共10000个)字符串对象作为共享对象,当redis使用这些字符串对象时,将会直接使用共享对象<ul><li>默认值通过参数<code class="language-plaintext highlighter-rouge">REDIS_SHARED_INTEGERS</code>进行改变<li>ver4.0:<code class="language-plaintext highlighter-rouge">OBJ_SHARED_INTEGERS</code></ul><li><code class="language-plaintext highlighter-rouge">object refcount [key]</code>:查看指定key对应的value的refcount值</ul><h2 id="string-1">string</h2><ul><li>通过redisObject进行存储,具有三种不同的编码方式(encoding):int, embstr, raw</ul><h3 id="int">int</h3><ul><li>当存储的字符串全为数字时,采用int存储</ul><h3 id="embstr">embstr</h3><ul><li>当存储的字符串长度小于44时,采用embstr存储<li>存储方式(连续存储):<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>redisObject
*ptr
SDS
</pre></table></code></div></div></ul><h3 id="raw">raw</h3><ul><li>当存储的字符串长度大于44时,采用raw存储<li>存储方式(SDS与redisObject在内存上不是连续存储):</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>redisObject
*ptr

SDS
</pre></table></code></div></div><h3 id="sds">SDS</h3><ul><li>Simple Dynamic String,经过封装的char*,但是包含了一个sdshdr的头部信息,结构:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">sdshdr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="n">T</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 数组长度</span>
    <span class="n">T</span> <span class="n">alloc</span><span class="p">;</span> <span class="c1">// 数组容量</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="c1">// sdshdr类型</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span> <span class="c1">// 数组内容</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="len">len</h4><ul><li>当前字符串数组的实际长度<li>因为c中的字符串获取长度是通过malloc函数获取的,时间复杂度为O(n),通过维护一个len字段可以在O(1)获取到长度<li>c中的字符串结尾通过是否为<code class="language-plaintext highlighter-rouge">\0</code>判断,会导致如图片等类型的文件无法正常保存,使用len来记录结尾可以保证二进制安全</ul><h4 id="alloc">alloc</h4><ul><li>当前字符串数组的内存长度<li>同java中的ArrayList,一个字符串数组的内存长度大于其实际长度<li>当字符串扩容时,如果<code class="language-plaintext highlighter-rouge">alloc - len</code>可以分配追加的内容,则直接追加;<li>如果剩余内存空间不足,则:<ul><li>字符串占用大小小于1M时,每次分配<code class="language-plaintext highlighter-rouge">len * 2</code><li>字符串占用大小大于1M时,每次分配1M</ul><li>通过动态分配内存,杜绝了缓冲区溢出的可能性</ul><h4 id="flags">flags</h4><ul><li>sdshdr的类型,共包含五种:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr5</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr8</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint8_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr16</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint16_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr32</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint32_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr64</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint64_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>flags的第三位表示sds类型:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4
</span></pre></table></code></div></div><ul><li>注:<code class="language-plaintext highlighter-rouge">__attribute__ ((__packed__))</code>使得gcc取消优化对齐,保证每个字段分配的内存地址是紧紧排列在一起的,这样可以使用sds[-1]（即buf[-1]）获取flags属性的内存地址,从而可以确定sdshdr的类型及属性</ul><p>##list</p><ul><li>底层存储方式分为<code class="language-plaintext highlighter-rouge">linkedList</code>(双向链表),<code class="language-plaintext highlighter-rouge">zipList</code>(连续的数组),<code class="language-plaintext highlighter-rouge">quickList</code>(前面二者的结合,ver3.2以后)<li>新list默认使用<code class="language-plaintext highlighter-rouge">zipList</code>,当发生以下情况时转变为<code class="language-plaintext highlighter-rouge">linkedList</code>:<ul><li>当向list中添加一个新的字符串值,且字符串长度超过<code class="language-plaintext highlighter-rouge">server.list_max_ziplist_value</code>设定的值(默认64)<li>ziplist包含的节点超过<code class="language-plaintext highlighter-rouge">server.list_max_ziplist_entries</code>设定的值(默认512)</ul><li>ver3.2:底层为quickList</ul><h3 id="linkedlist">linkedList</h3><ul><li>双向链表,结构:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span><span class="p">{</span>
    <span class="c1">//头指针</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">//尾指针</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="c1">//节点拷贝函数</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="c1">//释放节点函数</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="c1">//判断两个节点是否相等的函数</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">//链表长度</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>其中链表节点<code class="language-plaintext highlighter-rouge">listNode</code>结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span><span class="p">{</span>
    <span class="c1">//前一个节点</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="c1">//后一个节点</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="c1">//当前节点的值的指针</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="n">listNode</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>结构图: <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://voidblank.github.io/assets/markdown/redis-linkedlist.png" alt="" /></ul><h3 id="ziplist">ziplist</h3><ul><li>数组,支持双向遍历,结构为:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">ziplist</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="c1">//压缩列表占用字符数</span>
    <span class="kt">uint32_t</span> <span class="n">zlbytes</span><span class="p">;</span>
    <span class="c1">//从zlbytes的起始地址到最后一个entry的起始地址的偏移量,</span>
    <span class="c1">//通过该属性可以进行倒序遍历</span>
    <span class="kt">uint32_t</span> <span class="n">zltail_offset</span><span class="p">;</span>
    <span class="c1">//元素个数</span>
    <span class="kt">uint16_t</span> <span class="n">zllength</span><span class="p">;</span>
    <span class="c1">//元素内容</span>
    <span class="n">T</span><span class="p">[]</span> <span class="n">entries</span><span class="p">;</span>
    <span class="c1">//结束位 0xFF</span>
    <span class="kt">uint8_t</span> <span class="n">zlend</span><span class="p">;</span>
<span class="p">}</span><span class="n">ziplist</span>
</pre></table></code></div></div><ul><li>entry为存储的每个元素,结构如下</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">entry</span><span class="p">{</span>
    <span class="c1">//前一个entry的长度</span>
    <span class="kt">int</span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span> <span class="n">prelen</span><span class="p">;</span>
    <span class="c1">//元素类型编码</span>
    <span class="kt">int</span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="c1">//元素内容</span>
    <span class="n">optional</span> <span class="n">byte</span><span class="p">[]</span> <span class="n">content</span><span class="p">;</span>
<span class="p">}</span><span class="n">entry</span>
</pre></table></code></div></div><ul><li>结构图: <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://voidblank.github.io/assets/markdown/redis-ziplist.png" alt="" /></ul><h4 id="ziplist与linkedlist的比较">ziplist与linkedList的比较</h4><ul><li>双向链表的每个元素存有pre与next指针,占据额外内存<li>ziplist每个entry只存有元素,不需要保存额外的指针<li>双向链表因为元素在内存中不连续,所以进行内存管理时会出现大量碎片化内存,影响内存管理及gc<li>ziplist在内存中连续,进行减少碎片化,节约内存<li>双向链表在两端进行push与pop时,效率高<li>ziplist在连续内存区间内存储效率高,而修改、插入、删除则效率较低</ul><h4 id="ziplist的连锁更新">ziplist的连锁更新</h4><ul><li>entry中通过prelen保存了前一个entry的长度,大小根据下列原则:<ul><li>前一个节点的长度小于254个字节,则prelen长度为1字节<li>前一个节点的长度大于254字节,则prelen长度为5字节</ul><li>根据该原则,则在prelen长度为1字节的entry前(记作entry1),插入一个entry大于等于254字节的新节点(记作entry0),则会导致entry1的prelen增大为5字节<ul><li>若entry1在增大后导致其长度大小超过254字节,会导致后续entry也进行prelen更新,而这可能会导致连续多个entry都增大的情况<li>这种情况下会导致redis对该ziplist进行连续的内存分配直至结束,该情况称为连锁更新</ul><li>当触发连锁更新时,会将插入的时间复杂度变为O(n<sup>2</sup>)</ul><h3 id="quicklist">quickList</h3><ul><li>ver3.2之后新出现的数据结构<li>本身是一个双向链表,每个节点都使用ziplist来存储数据,节点直接包含了pre指针与next指针<li>图示: <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://voidblank.github.io/assets/markdown/redis-quicklist.png" alt="" /><li>结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklist</span><span class="p">{</span>
    <span class="n">quicklistNode</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">quicklistNode</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fill</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compressDepth</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>		
<span class="p">}</span><span class="n">quickList</span>
</pre></table></code></div></div><ul><li>其中,quicklistNode的结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">encoding</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">container</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recompress</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attempted_compress</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span> <span class="n">quicklistNode</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="quicklist结构">quicklist结构</h4><ul><li><code class="language-plaintext highlighter-rouge">*head</code>:头节点指针<li><code class="language-plaintext highlighter-rouge">*tail</code>:尾节点指针<li><code class="language-plaintext highlighter-rouge">count</code>:entry总数<li><code class="language-plaintext highlighter-rouge">len</code>:Node节点总数<li><code class="language-plaintext highlighter-rouge">fill</code>:ziplist设定<ul><li>当为负数时,表示每个节点的ziplist字节大小不能超过某个值<li>当为正数时,表示每个ziplist最多能容纳的entry数,上限为2<sup>15</sup><li>占16bit<li>通过<code class="language-plaintext highlighter-rouge">list-max-ziplist-size</code>设置,默认-2,为8kb</ul><li><code class="language-plaintext highlighter-rouge">compressDepth</code>:压缩算法深度<ul><li>为0时,不压缩<li>为1时,表示除了首尾各一个节点外都压缩<li>为2时,表示除了首尾各两个节点外都压缩<li>最大为2<sup>16</sup><li>通过<code class="language-plaintext highlighter-rouge">list-compress-depth</code>设置,默认为0</ul></ul><h4 id="quicklistnode结构">quicklistNode结构</h4><ul><li><code class="language-plaintext highlighter-rouge">*prev</code>:前一个Node节点<li><code class="language-plaintext highlighter-rouge">*next</code>:后一个Node节点<li><code class="language-plaintext highlighter-rouge">*zl</code>:当ziplist未压缩时指向一个ziplist,否则指向一个quicklistLZF<li><code class="language-plaintext highlighter-rouge">sz</code>:ziplist的总长度<li><code class="language-plaintext highlighter-rouge">count</code>:ziplist的节点数<li><code class="language-plaintext highlighter-rouge">encoding</code>:为1表示未压缩,为2表示已使用LZF压缩<li><code class="language-plaintext highlighter-rouge">container</code>:为2表示数据结构为ziplsit,为1表示非ziplist<li><code class="language-plaintext highlighter-rouge">recompress</code>:标记quicklist节点的ziplist之前是否被解压缩过,为1表示等待被再次压缩<li><code class="language-plaintext highlighter-rouge">attempted_compress</code>:?<li><code class="language-plaintext highlighter-rouge">extra</code>:拓展位</ul><h4 id="quicklistlzf结构">quicklistLZF结构</h4><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistLZF</span> <span class="p">{</span>
    <span class="c1">//表示被LZF算法压缩后的ziplist的大小</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span> <span class="cm">/* LZF size in bytes*/</span>
    <span class="c1">//保存压缩后的ziplist的数组，柔性数组</span>
    <span class="kt">char</span> <span class="n">compressed</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">quicklistLZF</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="ziplistentry结构">ziplistEntry结构</h4><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistEntry</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">quicklist</span> <span class="o">*</span><span class="n">quicklist</span><span class="p">;</span>   <span class="c1">//指向所属的quicklist的指针</span>
    <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>          <span class="c1">//指向所属的quicklistNode节点的指针</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zi</span><span class="p">;</span>            <span class="c1">//指向当前ziplist结构的指针</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>         <span class="c1">//指向当前ziplist结构的字符串vlaue成员</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">longval</span><span class="p">;</span>            <span class="c1">//指向当前ziplist结构的整数value成员</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>              <span class="c1">//保存当前ziplist结构的字节数大小</span>
    <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>                   <span class="c1">//保存相对ziplist的偏移量</span>
<span class="p">}</span> <span class="n">quicklistEntry</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="hash-1">hash</h2><ul><li>数据量小的时候采用ziplist,数据量大的时候采用dict<li>dict结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span><span class="p">{</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iterators</span><span class="p">;</span>
<span class="p">}</span><span class="n">dict</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>其中,dictht作为实际的哈希表,结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>其中,dictEntry数组存储数据</ul><h3 id="dict说明">dict说明</h3><ul><li><code class="language-plaintext highlighter-rouge">*type</code>:指向dictType的指针,通过自定义的方式使得dict的key和value能够存储任何类型的数据<li><code class="language-plaintext highlighter-rouge">*privdata</code>:私有数据,与<code class="language-plaintext highlighter-rouge">*type</code>配合从而实现多态<li><code class="language-plaintext highlighter-rouge">ht</code>:实际的哈希表,ht[0]是当前使用的表;ht[1]是空表,在改变容量的时候才会使用<li><code class="language-plaintext highlighter-rouge">rehashidx</code>:用于记录rehash的进度,为-1时表示没有rehash<li><code class="language-plaintext highlighter-rouge">iterators</code>:正在迭代的迭代器数量</ul><h3 id="dictht说明">dictht说明</h3><ul><li><code class="language-plaintext highlighter-rouge">**table</code>:二维数组,存储数据<li><code class="language-plaintext highlighter-rouge">size</code>:数组大小<li><code class="language-plaintext highlighter-rouge">sizemask</code>:哈希表的大小的掩码,用于计算索引值,总是等于size-1<li><code class="language-plaintext highlighter-rouge">used</code>:哈希表中元素的个数</ul><h3 id="扩容与缩容">扩容与缩容</h3><ul><li>dict解决哈希冲突:链表法<li>负载因子:哈希表中已保存节点数量/哈希表的大小<ul><li>计算: <code class="language-plaintext highlighter-rouge">ht[0].used / ht[0].size</code></ul><li>扩容规则:<ul><li>当没有执行<code class="language-plaintext highlighter-rouge">BGSAVE</code>或<code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code>指令时,负载因子大于等于1时扩容<li>当正在执行<code class="language-plaintext highlighter-rouge">BGSAVE</code>或<code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code>指令时,负载因子大于等于5时扩容<li>当负载因子小于0.1时,进行缩容操作</ul><li>扩容后,哈希表中的dictEntry的数组数量大于等于第一个大于等于<code class="language-plaintext highlighter-rouge">ht[0].used * 2</code>的2的幂<ul><li>在进行写盘操作时,进行扩容需要为ht[1]分配内存,若此时ht[0]较大,则会占用较多的内存空间,造成内存页过多<li>这会导致系统耗费更多的开销去回收内存</ul><li>缩容后,哈希表中的dictEntry的数组数量大于等于第一个大于等于<code class="language-plaintext highlighter-rouge">ht[0].used</code>的2的幂<ul><li>当满足缩容条件时,ht[0]的占用内存很小,即使为ht[1]分配内存也消耗不了太多资源</ul></ul><h3 id="rehash">rehash</h3><ul><li>因为单线程的Redis无法使用时间复杂度较高的全部rehash操作,所以采用了<code class="language-plaintext highlighter-rouge">渐进式rehash</code>的方式<ul><li>若数组在ht[0]中,则在ht[1]中分配空间,按照扩容/缩容的规则;<li>将dict中的<code class="language-plaintext highlighter-rouge">rehashidx</code>设置为0,表示rehash开始;<li>在rehash期间,对该字典进行增删改查的操作,程序除了进行制定操作外,还会将当前<code class="language-plaintext highlighter-rouge">ht[0][rehashidx]</code>链表上的所有元素rehash到<code class="language-plaintext highlighter-rouge">ht[1]</code>上,当完成一个链表后,rehashidx增1<li>当ht[0]所有的键值对都被rehash到ht[1]上时,rehash结束,<code class="language-plaintext highlighter-rouge">rehashidx</code>设为-1,表示rehash操作完成</ul><li>在rehash期间,对字典的新增操作会直接增加到ht[1]上<li>对字典的删改查的操作,会现在ht[0]上执行,若没有找到元素则会在ht[1]执行,若仍未找到则认为该key为空<li>由上文所说,当Redis内存占用较多时,rehash操作可能会导致部分key被抛弃</ul><h2 id="set-1">set</h2><ul><li>无序且存储不重复元素的集合,当value数据量不大且是整数值时,采用intset;否则采用dict</ul><h3 id="intset">intset</h3><ul><li>查找元素及插入元素采用二分法会先判断边界条件(首元素最小,尾元素最大)<li>结构:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">encoding</code>:编码格式,包括<code class="language-plaintext highlighter-rouge">INTSET_ENC_INT16</code>(16位,2个字节,默认),<code class="language-plaintext highlighter-rouge">INTSET_ENC_INT32</code>(32位,4个字节),<code class="language-plaintext highlighter-rouge">INTSET_ENC_INT64</code>(64位,8个字节)<li><code class="language-plaintext highlighter-rouge">length</code>:当前数组的长度,即有几个元素<li><code class="language-plaintext highlighter-rouge">contents</code>:存储元素的数组,从小到大排列且不包含任何重复项</ul><h4 id="intset新增元素时的升级过程">intset新增元素时的升级过程</h4><ul><li>若新增的元素超出当前编码格式的范围,则需要进行集合的升级操作<li>通过<code class="language-plaintext highlighter-rouge">length * encoding的位数</code>计算出当前的位范围<li>通过<code class="language-plaintext highlighter-rouge">length * 新encoding的位数</code>计算出需要划分的新的内存空间<li>通过上一步与单个encoding的位数,获得新插入元素所需的位范围,将元素插入(最前或最后)<li>将旧元素从后至前重新分配,这样可以有效防止数据被覆盖</ul><h2 id="zset">zset</h2><ul><li>根据score进行排序的有序的set集合,结构:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zset</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>其中,zset使用zskiplist进行score的排序,使用dict进行value-&gt;score的映射保存<li>取value时,直接通过dict在O(1)下获得value-score<li>进行增删改及排名查询操作时,会通过zskiplist进行操作,也会相对应的在dict中进行更新<li>因为使用了跳表,所以增删改查的时间复杂度为O(logN)<li>zskiplist的结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>其中,zskiplistNode为跳表的节点,结构如下:</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="zskiplist">zskiplist</h3><ul><li><code class="language-plaintext highlighter-rouge">*header</code>:跳表头指针<li><code class="language-plaintext highlighter-rouge">*tail</code>:跳表尾指针<li><code class="language-plaintext highlighter-rouge">length</code>:跳表中的元素个数,不包含头节点(头节点不是元素,仅是一个head)<li><code class="language-plaintext highlighter-rouge">level</code>:当前跳表中,所有节点中层数最大的level<li>最大层数64层,单个跳表最多可存储2<sup>64</sup>个元素<li>跳表是按照score升序排列的,两个score相同的元素,排序按照ele的字典序<li>一个zset中只有一个zskiplist,通过zskiplistNode的柔性数组来指向其他层级的后序节点</ul><h3 id="zskiplistnode">zskiplistNode</h3><ul><li><code class="language-plaintext highlighter-rouge">ele</code>:元素,存储的value值,sds类型<ul><li>在ver3.2中,存储的是redisObject类型的<code class="language-plaintext highlighter-rouge">*robj</code></ul><li><code class="language-plaintext highlighter-rouge">score</code>:元素的分数<li><code class="language-plaintext highlighter-rouge">*backward</code>:前驱指针,用于向前遍历<li><code class="language-plaintext highlighter-rouge">zskiplistLevel</code>:层级数组,有<ul><li><code class="language-plaintext highlighter-rouge">*forward</code>:后驱指针,向后遍历,同层级<li><code class="language-plaintext highlighter-rouge">span</code>:当前指针到下一个指针的跨度<li>数组的索引从0开始,表示层级,级别越小,表层级越低,表的元素越多</ul></ul><h3 id="增">增</h3><ul><li>从head开始降层查找最后一个比新增元素小的节点<li>插入元素,通过随机层数算法为该节点建立层数<li>更新最高层数</ul><h3 id="删">删</h3><ul><li>查找到指定元素,删除后更新指针及最高的层数</ul><h3 id="改">改</h3><ul><li>先查找元素,如果不存在则新增;<li>如果存在,则先删除后插入</ul><h3 id="查">查</h3><ul><li>通过跳表查询指定value及score,获得排名,如果查不到返回null</ul><h2 id="其他">其他</h2><h3 id="存储值中文乱码">存储值中文乱码</h3><ul><li><code class="language-plaintext highlighter-rouge">&gt;redis-cli --raw</code></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/redis/'>Redis</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/redis/" class="post-tag no-text-decoration" >redis</a> <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-tag no-text-decoration" >数据结构</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Redis基础 - voidblank&url=https://voidblank.github.io/posts/redis/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Redis基础 - voidblank&u=https://voidblank.github.io/posts/redis/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Redis基础 - voidblank&url=https://voidblank.github.io/posts/redis/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vuex/">Vuex</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><li><a href="/posts/spring-boot-%E6%B3%A8%E8%A7%A3/">SpringBoot 注解</a><li><a href="/posts/enable-google-pv/">Enable Google Page Views</a><li><a href="/posts/abstract-queued-synchronizer/">AQS</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><div class="card-body"> <span class="timeago small" > Apr 10 <i class="unloaded">2021-04-10T16:42:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构与算法</h3><div class="text-muted small"><p> 数据结构与算法 线性表 线性结构,头节点无前驱有一个后继,尾节点无后继有一个前驱。 只能顺序查找,查找时间复杂度O(n),删除时间复杂度O(1) 数组 顺序存储,连续存储,方便查找,可以随机查找元素,删除和插入较慢。 多维数组不是线性表 插入:时间复杂度O(n) 删除:时间复杂度O(n) 查找:时间复杂度O(n) 线性链表 链式存储结构,可以不...</p></div></div></a></div><div class="card"> <a href="/posts/mysql-basic/"><div class="card-body"> <span class="timeago small" > May 30 <i class="unloaded">2021-05-30T21:57:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL 基础</h3><div class="text-muted small"><p> MySQL 基础 DQL Data Query Language,数据查询语言 语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 -- 一 SELECT st_id AS id, st_name AS NAME FROM test_table1 t1, te...</p></div></div></a></div><div class="card"> <a href="/posts/abstract-queued-synchronizer/"><div class="card-body"> <span class="timeago small" > May 23 <i class="unloaded">2021-05-23T13:32:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AQS</h3><div class="text-muted small"><p> AbstractQueuedSynchronizer public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable AQS 成员变量 head private transient volatile N...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/enable-google-pv/" class="btn btn-outline-primary" prompt="Older"><p>Enable Google Page Views</p></a> <a href="/posts/python/" class="btn btn-outline-primary" prompt="Newer"><p>Python知识点总结目录</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">voidblank</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://voidblank.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
