<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="C++知识点总结目录" /><meta name="author" content="voidblank" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++知识点总结目录" /><meta property="og:description" content="C++知识点总结目录" /><link rel="canonical" href="https://voidblank.github.io/posts/cpp/" /><meta property="og:url" content="https://voidblank.github.io/posts/cpp/" /><meta property="og:site_name" content="voidblank" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-17T11:14:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++知识点总结目录" /><meta name="twitter:site" content="@voidblank" /><meta name="twitter:creator" content="@voidblank" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"voidblank"},"description":"C++知识点总结目录","headline":"C++知识点总结目录","dateModified":"2021-04-17T11:14:00+08:00","url":"https://voidblank.github.io/posts/cpp/","datePublished":"2021-04-17T11:14:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://voidblank.github.io/posts/cpp/"},"@context":"https://schema.org"}</script><title>C++知识点总结目录 | voidblank</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://imgur.com/oEa1xeJ.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">voidblank</a></div><div class="site-subtitle font-italic">just a blog!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/voidblank" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/voidblank" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['cy1245171920','outlook.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>C++知识点总结目录</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++知识点总结目录</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> voidblank </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 17, 2021, 11:14 AM +0800" prep="on" > Apr 17 <i class="unloaded">2021-04-17T11:14:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7077 words">39 min</span></div></div><div class="post-content"><h1 id="c知识点总结目录">C++知识点总结目录</h1><h2 id="数据类型">数据类型</h2><ul><li>字符型char:1个字节<li>整数型int:4个字节<li>短整数型short int:2个字节<li>长征属性long int:8个字节<li>浮点数型float:4个字节(7位)<li>长浮点数型double:8个字节(15位)<li>注:signed修饰，大小不变;unsigned修饰,大小不变,仅非负<li>typedef:自定义数据类型名称<ul><li>用法:<code class="language-plaintext highlighter-rouge">typedef unsigned int size_t;</code><li>也可以用于结构体上<li>与<code class="language-plaintext highlighter-rouge">#define</code>的比较:<ol><li><code class="language-plaintext highlighter-rouge">#define</code>可以用在任何位置，且是自声明起全局;<code class="language-plaintext highlighter-rouge">typedef</code>是局部的,在局部域声明若想全局使用需要<code class="language-plaintext highlighter-rouge">public:</code>声明<li><code class="language-plaintext highlighter-rouge">#define</code>是替换,不做检查;<code class="language-plaintext highlighter-rouge">typedef</code>是编译时检查<li>对指针的操作不同。<code class="language-plaintext highlighter-rouge">#define</code>设置为指针时:<code class="language-plaintext highlighter-rouge">#define PINT int *</code>;<code class="language-plaintext highlighter-rouge">typedef</code>设置为指针时:<code class="language-plaintext highlighter-rouge">typedef int * pint</code></ol></ul></ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="k">const</span> <span class="n">pint</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//p不可更改,p指向内容可以更改,相当于 int * const p;</span>
	<span class="k">const</span> <span class="n">PINT</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//p可以更改,p指向的内容不可更改,相当于 const int *p 或 int const *p</span>
	
	<span class="n">pint</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">;</span> <span class="c1">//s1, s2都是指针</span>
	<span class="n">PINT</span> <span class="n">s3</span><span class="p">,</span><span class="n">s4</span><span class="p">;</span> <span class="c1">//s3是指针</span>
</pre></table></code></div></div><h2 id="注释">注释</h2><ul><li>一般使用<code class="language-plaintext highlighter-rouge">//, /**/</code><li>嵌套<code class="language-plaintext highlighter-rouge">/**/</code>时会出现问题,这个使用可以使用<code class="language-plaintext highlighter-rouge">#if-#else-#endif</code>来注释中间的段落<li><code class="language-plaintext highlighter-rouge">#if</code>后面的条件为真时会执行,否则不执行</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cp">#if a
</span>		<span class="n">code</span><span class="p">;</span>
	<span class="cp">#else
</span>		<span class="n">code</span><span class="p">;</span>
	<span class="cp">#endif
</span></pre></table></code></div></div><h2 id="变量类型">变量类型</h2><ul><li>布尔值bool:true或false<li>字符型char:字符,可以转整数型<li>整数型int:基本类型<li>浮点型float:单精度浮点值,一位符号,8位指数,23位小数<li>浮点型double:双精度浮点值,一位符号,11位指数,52位小数<li>无类型void:表示缺失类型,一般用于函数返回值类型或是函数的参数<li>关于左值和右值:<ul><li>左值(lvalue):有内存指向的表达式,可以出现在赋值号的左边或右边,例如变量x<li>右值(rvalue):内存实际的数值,只能出现在赋值号的右边,例如50,’x’</ul><li>类型转换:<ul><li>若参与运算的类型不同,则会将其转换为同一类型进行运算<li>参与运算的类型,一般情况下会向着数据长度增加的方向进行,这是为了保证精度不丢失。例如int long会都转换成long<li>字节数不同的类型,向着字节数大的方向转换<li>字节数相同,一种为signed,一种为unsigned,那么就转换成unsigned<li>所有浮点值的运算本质上都是转换为double运算,即使都是float也是如此<li>char和short运算时会先转换成int<li>赋值运算时,赋值号右侧的值会转换成左侧的值,即使精度会丢失</ul><li>变量的声明:<ul><li>因为c++是自上而下执行的,所以如果前面的域使用了后面定义的变量,那么可以使用<code class="language-plaintext highlighter-rouge">extern</code>关键字来声明&lt;/br&gt;注意:是声明不是定义,声明可以多次但定义只能有一次<li>对本文件内的全局变量在局部域使用时,可以<code class="language-plaintext highlighter-rouge">::x</code>来调用</ul></ul><h2 id="常量">常量</h2><ul><li>使用宏定义<code class="language-plaintext highlighter-rouge">#define</code><li>使用const定义<code class="language-plaintext highlighter-rouge">const int x</code><li>区别:<ol><li>宏定义是字符替换,没有安全检查,可能产生边际效应等错误;const是常量声明,有类型区别,会在编译阶段进行检查<li>宏定义是编译时概念,在预处理阶段展开;const时运行时概念,在程序运行时使用,类似于一个只读数据<li>宏定义是直接替换,不会分配内存,存储在程序的代码段中;const需要分配内存,存储在程序的数据段中<li>可以使用<code class="language-plaintext highlighter-rouge">#undef</code>来使之前定义的宏定义失效;const在定义域内永久有效</ol><li>关于const指针:<ul><li><code class="language-plaintext highlighter-rouge">char * const p</code>:p is a const pointer to char<li><code class="language-plaintext highlighter-rouge">const char * p</code>:p is a pointer to const char<li>即:从右向左读(*读作pointer to)</ul></ul><h2 id="存储类">存储类</h2><h3 id="static">static</h3><ul><li>表示该变量在程序的生命周期内保持存在,而不需要在每次进入和离开的时候进行创建和销毁<li>在全局域内使用static时,该变量的作用域会限制在文件内<li>在修饰类成员时,会导致该类成员被所有对象共享;若这个类成员时public,那么可以直接通过类名调用;这个类成员的数据会在声明的时候初始化<li>关于static在类的继承上的使用参照后续面向对象</ul><h3 id="extern">extern</h3><ul><li>表示在此处声明在其他文件/本文件后续定义的变量<li>extern可以多次声明,但变量的定义只有一次<li>可以两个文件相互声明,不过阅读上会有麻烦</ul><h3 id="thread_local">thread_local</h3><ul><li>表示该变量仅可在其创建上的线程上访问,当线程创建时创建,线程销毁时销毁<li>根据这一特性可以使用析构函数来获知线程的销毁事件<li>可以和static和extern联合使用</ul><h2 id="运算符">运算符</h2><ul><li>+,-,*,/,%,++,–:<ul><li>算术运算符,不再赘述</ul><li>==,!=,&gt;,&gt;=,&lt;,&lt;=:<ul><li>关系运算符,不再赘述</ul><li><div class="table-wrapper"><table><tbody><tr><td>&amp;&amp;,<td> <td>,!:</table></div><ul><li>逻辑运算符,不再赘述</ul><li><div class="table-wrapper"><table><tbody><tr><td>&amp;,<td>,^,~,«,»:</table></div><ul><li>位运算符<li>若A = 0011 1010, B = 0100 1011,那么:<ul><li>A&amp;B = 0000 1010(都为1则为1,否则为0)<li><div class="table-wrapper"><table><tbody><tr><td>A<td>B = 0111 1011(一个为1则为1,否则为0)</table></div><li>A^B = 0111 0001(有且仅有一个为1则为1,否则为0)<li>~A = 1100 0101(颠倒0和1)<li>A«2 = 1110 1000(向左移动2位)<li>A»2 = 0000 1110(向右移动2位)</ul></ul><li><div class="table-wrapper"><table><tbody><tr><td>=,+=,-=,*=,/=,%=,«=,»=,&amp;=,^=,<td>=:</table></div><ul><li>赋值运算符,不再赘述</ul><li>sizeof,Condition?x:y, , ,.,-&gt;,Cast,&amp;,*:<ul><li>杂项运算符<li>sizeof(data type):返回一个整数,表示这个变量或数据类型占用的空间大小,可以用于类,结构体等<li>Condition?x:y:条件运算符,如果Condition成立则值为x,否则为y<li>,:逗号运算符,顺序执行一系列运算,整个表达式的值是最后一个表达式的值,在所有的运算符中序列最低<li>.和-&gt;:成员运算符,用于引用类,结构体成员<li>Cast:强制转换运算符,例如(int)x<li>&amp;:指针运算符,返回内存地址,其他操作参照后续指针<li>*:指针运算符,返回地址所指的值,其他操作参照后续指针</ul><li>sizeof:<ul><li>对系统类型时,返回他们所占的字节数。如sizeof(int)返回4<li>对结构体时:<ul><li>没有成员的结构体:1<li>含有混合类型成员的结构体:字节数最大的*成员个数<li>对于union时:最大字节数</ul><li>对于指针(包括参数传递时的数组):4。如:func(int[] a){sizeof(a);}这里返回4<li>对于数组:<ul><li><code class="language-plaintext highlighter-rouge">char a[10];</code>sizeof(a)返回10<li><code class="language-plaintext highlighter-rouge">char a[] = "abc";</code>sizeof(a)返回4,结尾有个’/0’</ul></ul></ul><h2 id="数字">数字</h2><ul><li>随机数:<ul><li><code class="language-plaintext highlighter-rouge">srand(unsigned seed)</code>设置随机种子<li>需要<code class="language-plaintext highlighter-rouge">#include&lt;cstdlib&gt;</code><li>一般这样设置随机种子:<code class="language-plaintext highlighter-rouge">srand((unsigned) time(NULL))</code><ul><li>需要<code class="language-plaintext highlighter-rouge">#include&lt;ctime&gt;</code></ul><li>使用时,<code class="language-plaintext highlighter-rouge">n = rand() % 100</code>,相当于获取100以内的随机数</ul></ul><h2 id="数组和字符串">数组和字符串</h2><ul><li>使用<code class="language-plaintext highlighter-rouge">cout</code>输出指定格式的字符串:<ul><li><code class="language-plaintext highlighter-rouge">cout&lt;&lt;setfill('*')&lt;&lt;setw(5)&lt;&lt;'a'&lt;&lt;endl;</code><li>输出效果:<code class="language-plaintext highlighter-rouge">****a</code></ul><li>获取字符串数组长度:<code class="language-plaintext highlighter-rouge">strlen(str)</code><li>获取数组长度:<code class="language-plaintext highlighter-rouge">end(array) - begin(array)</code><li>字符串(char)的相关函数:<ul><li><code class="language-plaintext highlighter-rouge">strcpy(s1, s2)</code>:复制s2给s1<li><code class="language-plaintext highlighter-rouge">strcat(s1, s2)</code>:将s2接在s1后面<li><code class="language-plaintext highlighter-rouge">strcmp(s1, s2)</code>:若s1与s2相同,返回0;若s1 &lt; s2,返回值小于0;若s1 &gt; s2,返回值大于0<li><code class="language-plaintext highlighter-rouge">strchr(s1, ch)</code>:返回一个指针,ch第一次在s1出现的位置<li><code class="language-plaintext highlighter-rouge">strstr(s1, s2)</code>:返回一个指针,s2第一次在s1出现的位置</ul><li>字符串(string)的相关函数:<ul><li><code class="language-plaintext highlighter-rouge">str.append(s)</code>:在str尾部添加s<li><code class="language-plaintext highlighter-rouge">str.length()</code>:返回整数,str的长度<li><code class="language-plaintext highlighter-rouge">str.find(s)</code>:返回s在str的位置<li><code class="language-plaintext highlighter-rouge">str.replace(i, n, s)</code>:从i位置开始,之后的4个字符替换成s,若s是”“,则相当于是删除<li><code class="language-plaintext highlighter-rouge">str.insert(start, len, char)</code>:从start位置开始,添加char字符,共len个<li><code class="language-plaintext highlighter-rouge">str.insert(start, s)</code>:在start处添加字符串s<li><code class="language-plaintext highlighter-rouge">cin.getline()</code>:获取输入字符串,直至输入回车&lt;/br&gt;建议使用<code class="language-plaintext highlighter-rouge">getline(cin, str)</code>,可以直接使用字符串<li><code class="language-plaintext highlighter-rouge">cin.ignore(int n, char a)</code>:忽略cin流的字符,直至:个数达到n或遇到字符a;为空时等价于<code class="language-plaintext highlighter-rouge">cin.ignore(1, EOF)</code></ul></ul><h2 id="指针">指针</h2><ul><li>指针是一个变量,其值是另一个变量的地址,即内存的直接地址</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="kt">int</span> <span class="n">var</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">};</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="c1">//等价于ptr = &amp;var[0];</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//输出的是10的地址</span>
	<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//输出的是10</span>
	<span class="n">ptr</span><span class="o">++</span><span class="p">;</span> <span class="c1">//指针移动4个字节</span>
	<span class="c1">//对于这个例子,*ptr++与*(ptr++)是一样的</span>
</pre></table></code></div></div><ul><li>指向指针的指针:<code class="language-plaintext highlighter-rouge">char **ptr</code></ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="kt">char</span> <span class="o">*</span><span class="n">var</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"this"</span><span class="p">,</span> <span class="s">"all"</span><span class="p">};</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
	<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//返回hello的地址</span>
	<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr</span><span class="o">++&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//返回hello</span>
	<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//返回world</span>
	<span class="n">cout</span><span class="o">&lt;&lt;**</span><span class="n">ptr</span><span class="o">++&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//返回w</span>
	<span class="n">cout</span><span class="o">&lt;&lt;**</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//返回o</span>
</pre></table></code></div></div><ul><li>函数也可以使用指针,使得自身的返回值是一个指针</ul><h2 id="引用">引用</h2><ul><li>引用变量是一个别名,是某个已存在的变量的另一个名字<li>不存在空引用,但存在空指针<li>引用一旦被初始化,就不能更改对象;指针随时可以更改对象<li>引用在创建时即被初始化;指针可以随时初始化<li>创建引用的例子:</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//引用变量</span>
</pre></table></code></div></div><ul><li>引用创建的时候不会开辟内存空间,但是如果是<code class="language-plaintext highlighter-rouge">x = y</code>则会额外开辟内存空间<li>函数传递时:<code class="language-plaintext highlighter-rouge">int swap(int&amp; a, int&amp; b)</code>使用引用,这样就可以传递数值,而a,b不会开辟新的内存空间;通常方式的形参会开辟新的内存空间<li>函数如果参数使用了引用,那么就不能将常量传入<li>将引用作为函数的返回值:</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="c1">//	return p; 错误,不能返回局部变量</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//正确</span>
	<span class="err">｝</span>
	<span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">//引用可以实现这个效果,使得函数可以变为左值</span>
</pre></table></code></div></div><h2 id="时间日期">时间日期</h2><ul><li>需要<code class="language-plaintext highlighter-rouge">#include&lt;ctime&gt;</code><li>获取当前时间:<code class="language-plaintext highlighter-rouge">time_t now = time(0);</code>&lt;/br&gt;<code class="language-plaintext highlighter-rouge">char *dt = ctime(&amp;now);</code><li>使用tm结构体来获取时间的每一个参数:</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="n">tm</span> <span class="o">*</span><span class="n">ltm</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"年: "</span><span class="o">&lt;&lt;</span> <span class="mi">1900</span> <span class="o">+</span> <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"月: "</span><span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"日: "</span><span class="o">&lt;&lt;</span>  <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_mday</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"时间: "</span><span class="o">&lt;&lt;</span> <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ltm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="结构体">结构体</h2><ul><li>与类的区别:<ol><li>class默认成员访问权限是private,struct默认成员访问权限是public<li>class默认继承是private继承,struct默认继承是public<li>class可以定义模版,struct不可以</ol><li>结构体指针:<ul><li>如果是指针,在获取成员时要使用-&gt;</ul></ul><p>##C++面向对象</p><h3 id="类">类</h3><h4 id="类访问修饰符">类访问修饰符:</h4><ul><li>public:所有人都可以访问<li>protected:只有自身和子类(派生类)可以访问<li>private:只有自身和友元可以访问<li>如果不写出修饰符,默认是private</ul><h4 id="继承时的修饰符">继承时的修饰符:</h4><ul><li>public:public-&gt;public,protected-&gt;protected,private-&gt;private<li>protected:public-&gt;protected,protected-&gt;protected,private-&gt;private<li>private:都变为private</ul><h4 id="友元">友元:</h4><ul><li>定义在类外部的函数或类,在类内部需要说明,前面加friend关键词<li>友元可以访问private成员及函数<li>友元不具有对称性,也不具有传递性<li>友元关系不会被继承<li>友元函数没有this指针,直接调用即可</ul><h4 id="构造函数和析构函数">构造函数和析构函数:</h4><ul><li>构造函数:<ul><li>同java的构造器,用于该类创建时执行<li>一般用来赋初值,或是获取类创建的事件</ul><li>析构函数:<ul><li>与构造函数类似,在类销毁的时候执行<li>前加<code class="language-plaintext highlighter-rouge">~</code><li>可以用来获取类销毁的事件</ul><li>关于多态中析构函数和构造函数:<ul><li>例如:(A是B的父类)<code class="language-plaintext highlighter-rouge">A *a = new B();</code><li>先执行A的构造函数,再执行B的构造函数<li>销毁时,仅执行A的析构函数</ul><li>多重继承:<ul><li>多重继承时,先构造的后析构<li>先调用基类的构造函数,再调用派生类的构造函数</ul></ul><h4 id="拷贝构造函数">拷贝构造函数:</h4><ul><li>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：<ul><li>通过使用另一个同类型的对象来初始化新创建的对象。<li>复制对象把它作为参数传递给函数。<li>复制对象，并从函数返回这个对象。</ul></ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="n">classname</span><span class="p">(</span><span class="k">const</span> <span class="n">classname</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>	<span class="c1">//const起保护作用</span>
		<span class="n">code</span><span class="p">;</span>
	<span class="p">}</span>
</pre></table></code></div></div><h4 id="内联函数">内联函数:</h4><ul><li>如果一个函数时内联的,那么在编译时,编译器会把该函数的代码副本放置在每个调用该函数的地方<li>需要使用关键词<code class="language-plaintext highlighter-rouge">inline</code><li>类定义中的定义的函数都是类的内联函数,即使没有inline<li>内联函数的定义必须出现在内联函数第一次调用之前<li>函数体较小的情况下可以考虑使用内联函数来空间换时间,但是滥用内联函数会使得程序变慢,一般不会内联超过十行的函数</ul><h3 id="继承">继承</h3><ul><li>父类也称为基类,子类也称为派生类<li>c++可以进行多继承,书写格式:<code class="language-plaintext highlighter-rouge">class className: &lt;修饰符&gt; basicClass1, &lt;修饰符&gt;basicClass2,...</code><li>对于虚函数来说,会按照从左到右的顺序对基类虚函数进行覆盖<li>对于环装继承来说:<ul><li>A-&gt;D,B-&gt;D,C-&gt;(A,B)对于这种情况,C会创建两个D的对象。为了避免这种情况,使用虚继承<li>下面代码相当于继承D,A,B,C</ul></ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="k">class</span> <span class="nc">D</span><span class="p">{...}</span>
	<span class="k">class</span> <span class="nc">A</span><span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">D</span><span class="p">{...}</span>
	<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">D</span><span class="p">{...}</span>
	<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">,</span> <span class="k">public</span> <span class="n">B</span><span class="p">{...}</span>
</pre></table></code></div></div><h3 id="重载">重载</h3><ul><li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。<li>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。<li>重载运算符的定义:<code class="language-plaintext highlighter-rouge">classname operator+(const classname&amp;)</code>&lt;/br&gt;这是+的重载<li>可以重载的运算符:<ul><li>双目算术运算符:+,-,*,/,%<li>关系运算符:==,!=,&lt;,&gt;,&lt;=,&gt;=<li><div class="table-wrapper"><table><tbody><tr><td>逻辑运算符:<td> <td>,==,!</table></div><li>单目运算符:+(正),-(负),*(指针),&amp;(取地址)<li>自增自减运算符:++,–<li><div class="table-wrapper"><table><tbody><tr><td>位运算符:<td>,&amp;,~,^,«,»</table></div><li><div class="table-wrapper"><table><tbody><tr><td>赋值运算符:+=,-=,*=,/=,%=,&amp;=,<td>=,«=,»=</table></div><li>空间申请与释放:new,delete,new[],delete[]<li>其他运算符:()(函数调用),-&gt;(成员访问), ,(逗号),[](下标)</ul></ul><h3 id="类的重载覆盖重定义的区别">类的重载，覆盖，重定义的区别:</h3><ul><li>重载指的是函数具有的不同的参数列表，而函数名相同的函数。重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。如果仅仅是函数的返回值不同是没办法重载的，因为重载要求参数列表必须不同。（发生在同一个类里）<li>覆盖是存在类中，子类重写从基类继承过来的函数。被重写的函数不能是<code class="language-plaintext highlighter-rouge">static</code>的。必须是<code class="language-plaintext highlighter-rouge">virtual</code>的。但是函数名、返回值、参数列表都必须和基类相同（发生在基类和子类）<li>重定义也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。（发生在基类和子类）</ul><h3 id="虚函数">虚函数</h3><ul><li>虚函数是在基类中使用关键字<code class="language-plaintext highlighter-rouge">virtual</code>声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<li>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定<li>虚函数实际上是通过虚函数表实现的<li>纯虚函数:<ul><li>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。<li>类似于java中的抽象函数,或是接口下的方法(即完全依靠子类去实现方法,而基类只负责告诉子类需要实现什么方法)<li>实例:<code class="language-plaintext highlighter-rouge">virtual int area() = 0;</code></ul><li>如果不希望一个类或是方法被继承,那么可以使用<code class="language-plaintext highlighter-rouge">final</code>关键字(c++11)<ul><li>例:<code class="language-plaintext highlighter-rouge">class className final{...}</code>&lt;/br&gt;<code class="language-plaintext highlighter-rouge">int func() final{...}</code></ul></ul><h2 id="文件和流io">文件和流(IO)</h2><ul><li>一般情况下使用<code class="language-plaintext highlighter-rouge">#include&lt;iostream&gt;</code>时,使用的输入输出流是<code class="language-plaintext highlighter-rouge">cin</code><code class="language-plaintext highlighter-rouge">cout</code><li>文件处理时,需要<code class="language-plaintext highlighter-rouge">#include&lt;iostream&gt;</code>和<code class="language-plaintext highlighter-rouge">#include&lt;fstream&gt;</code><li>文件流的三种类型:<ul><li>ofstream:输出文件流,用于创建文件并向文件写入信息<li>ifstream:输入文件流,用于从文件读取信息<li>fstream:文件流,具有上述两种功能</ul><li>函数:<ul><li>创建一个对象:<code class="language-plaintext highlighter-rouge">fstream f;</code>或<code class="language-plaintext highlighter-rouge">ofstream ofile;</code>或<code class="language-plaintext highlighter-rouge">ifstream ifile;</code><li>打开文件:<code class="language-plaintext highlighter-rouge">f.open(const char *filename, ios::openmode mode);</code><ul><li>三种类型都有此函数<li>openmode:打开模式<li><code class="language-plaintext highlighter-rouge">ios::app</code>:追加模式,所有文件追加到文件尾<li><code class="language-plaintext highlighter-rouge">ios::ate</code>:文件打开后定位到文件尾<li><code class="language-plaintext highlighter-rouge">ios::in</code>:打开文件用于读取<li><code class="language-plaintext highlighter-rouge">ios::out</code>:打开文件用于写入<li><code class="language-plaintext highlighter-rouge">ios::trunc</code>:若文件已存在,则清空文件内容<li><div class="table-wrapper"><table><tbody><tr><td>可以使用<td>来使用多个模式</table></div></ul><li>关闭文件:<code class="language-plaintext highlighter-rouge">f.close();</code><ul><li>三种类型都有此函数<li>释放内存,刷新流,文件使用结束后记得使用</ul><li>向文件读写:<ul><li>读取文件内容:<code class="language-plaintext highlighter-rouge">ifile&gt;&gt;data;</code><li>向文件写入内容:<code class="language-plaintext highlighter-rouge">ofile&lt;&lt;data&lt;&lt;endl;</code></ul></ul></ul><h2 id="异常处理">异常处理</h2><ul><li>对异常进行捕获处理<li>常规结构:<code class="language-plaintext highlighter-rouge">try-catch</code><li>可以使用<code class="language-plaintext highlighter-rouge">throw</code>来抛出异常</ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="k">try</span><span class="p">{</span>
		<span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">;</span>
	<span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">){</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//使用exception的what(),返回异常产生的原因</span>
	<span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">){</span>
		<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">msg</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//使用cerr流,msg时异常的信息</span>
	<span class="p">}</span>							<span class="c1">//二选一使用即可</span>
</pre></table></code></div></div><h2 id="动态内存">动态内存</h2><ul><li>c++程序内存:<ul><li>栈:在函数内部声明的所有变量都将占用栈内存<li>堆:程序中未使用的内存,在程序运行时可用于动态分配内存</ul><li>new,delete运算符:<ul><li>new在使用时不仅分配了内存,还创建了对象<li>可以使用<code class="language-plaintext highlighter-rouge">if(value = new int)</code>来判断是否有足够空间来创建新的对象<li>当使用new来创建一个类的对象时,要注意:<ul><li><code class="language-plaintext highlighter-rouge">myClass *p = new myClass[4];</code><li>如果这样创建对象,那么相当于调用了4次构造函数,销毁时也会调用4次析构函数</ul><li>delete用在new出来的对象不需要时,将其销毁<li>delete的两种情况分析:<ul><li>对于简单的数据类型(如int,char),那么<code class="language-plaintext highlighter-rouge">delete a;</code>与<code class="language-plaintext highlighter-rouge">delete []a;</code>效果相同<li>对于对象来说,那么要使用<code class="language-plaintext highlighter-rouge">delete []a;</code>,因为若使用<code class="language-plaintext highlighter-rouge">delete a;</code>只会释放掉a指针指向的所有空间及a[0]的内存空间,而造成了其他的内存空间无法释放,从而造成了内存泄漏</ul></ul></ul><h2 id="模版template">模版(template)</h2><ul><li>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。<li>函数模版:<ul><li>格式:<code class="language-plaintext highlighter-rouge">template &lt;class type&gt; ret-type funcName(parameter list){...}</code><li>template:模版关键词<li>class type:数据类型的占位符,泛型T;你可以使用逗号来分隔多个泛型<li>ret-type:函数返回值类型<li>parameter list:参数列表,这里可以使用class type类型,使得参数是泛型<li>函数模版可以重载,只要形参列表不同即可</ul><li>类模版:<ul><li>格式:<code class="language-plaintext highlighter-rouge">template &lt;class type&gt; class className{...}</code><li>类的内部成员和函数都可以使用泛型</ul></ul><h2 id="预处理器">预处理器</h2><ul><li>以#开头的指令,会在编译前处理<li>#include:将头文件包含到源文件中,使用”“则优先在当前目录下寻找,使用&lt;&gt;则优先在系统目录下寻找<li>#define:创建符号常量,也可以创建参数宏<li>#if:条件编译,结尾使用#endif表示结束<li>预定义宏:<ul><li><code class="language-plaintext highlighter-rouge">__LINE__</code>:当前行号<li><code class="language-plaintext highlighter-rouge">__FILE__</code>:当前文件名<li><code class="language-plaintext highlighter-rouge">__DATE__</code>: 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。<li><code class="language-plaintext highlighter-rouge">__TIME__</code>: 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</ul></ul><h2 id="多线程">多线程</h2><ul><li>使用<code class="language-plaintext highlighter-rouge">thread</code>文件下的<code class="language-plaintext highlighter-rouge">std::thread</code>类进行多线程编程<li>创建线程的方法:<ul><li><code class="language-plaintext highlighter-rouge">std::thread threadName(funcName);</code>无参直接创建<li><code class="language-plaintext highlighter-rouge">std::thread threadName(funcName, arg1, arg2, ...);</code>有参数时,按照顺序填写参数<li><code class="language-plaintext highlighter-rouge">std::thread threadName(funcName, classObj, arg1, arg2, ...);</code>等价于<code class="language-plaintext highlighter-rouge">classObj.funcName(arg1, arg2, ...);</code><li>一旦线程创建了,会直接run,不需要手动run</ul><li>等待线程直至结束:<code class="language-plaintext highlighter-rouge">threadName.join();</code><li>线程等待:<code class="language-plaintext highlighter-rouge">threadName.wait();</code>,等待直至<code class="language-plaintext highlighter-rouge">notify_one</code>或是<code class="language-plaintext highlighter-rouge">notify_all</code>唤醒<li>线程锁:<ul><li>互斥锁mutex:<ul><li>创建:<code class="language-plaintext highlighter-rouge">std::mutex mtx;</code><li>使用:<code class="language-plaintext highlighter-rouge">mtx.lock();</code>若已被加锁,线程阻塞;&lt;/br&gt;解锁:<code class="language-plaintext highlighter-rouge">mtx.unlock();</code><li>尝试加锁,若未被加锁,则执行加锁操作,返回true;否则返回false:<code class="language-plaintext highlighter-rouge">mtx.try_lock();</code></ul></ul></ul><h2 id="常用标准容器">常用标准容器</h2><h3 id="顺序容器">顺序容器</h3><h4 id="vector">vector</h4><ul><li>定义/初始化:<ol><li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1</code> 默认初始化,v1此时为空<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1(v2)</code>初始化v1并赋值v2给v1<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1 = v2</code>同2<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1(n)</code> 初始化v1并设置他的size为n,默认值和T的类型有关,不建议<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1(n, a)</code>初始化v1并设置他的size为n,填充a<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1{a, b, c}</code>初始化v1并设置现有元素为a,b,c<li><code class="language-plaintext highlighter-rouge">vector&lt;T&gt; v1 = {a, b, c}</code>同6</ol><li>属性操作:<ol><li><code class="language-plaintext highlighter-rouge">v1.size()</code>返回v1当前的元素数量<li><code class="language-plaintext highlighter-rouge">v1.capacity()</code>返回v1当前的容量(空间)<li><code class="language-plaintext highlighter-rouge">v1.empty()</code>返回v1是否为空<li><code class="language-plaintext highlighter-rouge">v1.max_size()</code>返回v1最大可存放元素数目<li><code class="language-plaintext highlighter-rouge">v1.shrink_to_fit()</code>将v1的capacity压缩至size大小,节约空间</ol><li>访问操作:<ol><li><code class="language-plaintext highlighter-rouge">v1[n]</code>返回n位置上的元素,注意这个位置必须有元素才可以,否则会崩溃<li><code class="language-plaintext highlighter-rouge">v1.at(n)</code>返回n位置上的元素,若不存在则抛出out_of_range异常<li><code class="language-plaintext highlighter-rouge">v1.front()</code>返回头部元素的引用,注意判断是否为空<li><code class="language-plaintext highlighter-rouge">v1.back()</code>返回尾部元素的引用,注意判断是否为空</ol><li>添加操作:<ol><li><code class="language-plaintext highlighter-rouge">v1.push_back(a)</code>在迭代器尾部添加元素a<li><code class="language-plaintext highlighter-rouge">v1.insert(iter, a)</code>将元素a插入iter的前面,返回新迭代器<li><code class="language-plaintext highlighter-rouge">v1.emplace_back(a)</code>在尾部放至元素a,c++11后建议使用,效率高于push_back()</ol><li>删除操作:<ol><li><code class="language-plaintext highlighter-rouge">v1.erase(iterator)</code>删除iter指定元素,返回被删除元素的下一个元素,效率低下,不建议使用<li><code class="language-plaintext highlighter-rouge">v1.pop_back()</code>删除尾部元素,注意判断是否为空<li><code class="language-plaintext highlighter-rouge">v1.clear()</code>清空所有元素</ol><li>替换元素:<ol><li><code class="language-plaintext highlighter-rouge">v1.assign(n, a)</code>清空v1,将n个值为a的元素填入<li><code class="language-plaintext highlighter-rouge">v1.assign(iter1, iter2)</code>清空v1,将iter1到iter2间的元素填入</ol><li>在连续空间存储元素,可以进行随机访问,对尾部的元素可以高效进行增删操作,但对头部和中部元素的增删操作效率低<li>只要进行了增删操作,迭代器就会失效,变成随机状态<li>迭代器可以使用<code class="language-plaintext highlighter-rouge">++iter</code>和<code class="language-plaintext highlighter-rouge">--iter</code>操作,也可进行+,-操作</ul><h4 id="array">array</h4><ul><li>定义及初始化:<code class="language-plaintext highlighter-rouge">std::array&lt;typeName, size&gt; arr = {}</code><li>效率和数组一致,长度也是初始设置的,元素存储在栈空间,但比数组更安全,推荐使用array替代数组<li>如果数组越界,不会报错,因为array重写了该机制<li>对数组排序:<code class="language-plaintext highlighter-rouge">std::sort(arr.begin(), arr.end());</code></ul><h4 id="list">list</h4><ul><li>由双向链表实现,所以即使增删操作也不会使迭代器失效<li>不能随机访问,只能遍历访问<li>可以使用<code class="language-plaintext highlighter-rouge">push_front()</code>及<code class="language-plaintext highlighter-rouge">pop_front()</code><li>将两个list部分拼接的操作:<ul><li><code class="language-plaintext highlighter-rouge">myList1.splice(position, listX, iterFirst, iterEnd);</code><li>position:迭代器,要插入的位置,一般创建方法:<code class="language-plaintext highlighter-rouge">list&lt;T&gt; iter = myList.begin();</code><br />可以使用++来调整位置,也可以使用<code class="language-plaintext highlighter-rouge">myList.end();</code><li>listX:从该list取元素,注意如果listX和position来自同一链表,可能会形成环<li>iterFirst:从listX取的首个元素的迭代器,包含该元素<li>iterEnd:取元素直至该迭代器,不包含该元素<li>如果参数仅为position, listX则会将listX的所有元素拼接<li>如果不使用iterFirst及iterEnd,而是使用iter,则仅会将iter所指元素进行变动<li>执行splice后,listX被改动的元素会从listX中删除</ul><li>将两个list拼接到一起的操作:<ul><li><code class="language-plaintext highlighter-rouge">myList1.merge(myList2, cmp);</code><li>将myList2和myList1拼接,myList2会变为空<li>cmp用来做两个list的元素大小判断<li>如果原来的两个list有顺序,那么合成后的也有顺序<li>如果不想排序,建议使用splice</ul><li>反转:<ul><li><code class="language-plaintext highlighter-rouge">myList1.reverse();</code><li>将list反转</ul></ul><h4 id="deque">deque</h4><ul><li>双向队列,可以使用vector及list的所有方法<li>在首尾处理时速度较快,中间元素处理较慢<li>可以随机访问,但效率低于vector;对首尾元素的处理效率低于list<li>没有reverse及capacity方法<li>除了首尾的插入删除操作外,其他地方的插入删除操作均会使迭代器,指针,引用失效,一般情况下参考vector<li>vector所有元素都是连续空间存储,deque是部分连续存储</ul><h4 id="forward_lsit">forward_lsit</h4><ul><li>单向链表,向前添加/删除元素,故部分方法只有front方法<li>没有size()方法<li>不会因插入删除元素导致迭代器失效</ul><h4 id="stack">stack</h4><ul><li>栈,先入后出,后入先出<li>只能对栈顶元素进行处理,其他元素只有在上方的元素都被删除后才能处理<li>由deque实现<li>创建:<code class="language-plaintext highlighter-rouge">std::stack&lt;int&gt;stk;</code><li>压栈:<code class="language-plaintext highlighter-rouge">stk.push(element);</code><li>出栈:<code class="language-plaintext highlighter-rouge">stk.pop();</code><li>判断是否为空:<code class="language-plaintext highlighter-rouge">stk.empty();</code><li>栈元素个数:<code class="language-plaintext highlighter-rouge">stk.size();</code><li>栈顶元素:<code class="language-plaintext highlighter-rouge">stk.top();</code><li><h3 id="有序关联容器">有序关联容器:</h3></ul><h4 id="map">map</h4><ul><li>封装红黑平衡二叉树,使用k-v对存储<li>可以使用[]来获取对应value或用迭代器遍历全部<li>创建map:<code class="language-plaintext highlighter-rouge">std::map&lt;string, int&gt;m;</code><li>插入值:<code class="language-plaintext highlighter-rouge">m[string("abcdef")] = 1;</code>或使用pair来insert<li>查找元素:<code class="language-plaintext highlighter-rouge">it = m.find(element);</code>若返回的是m.end(),则说明不存在<li>删除:<code class="language-plaintext highlighter-rouge">m.earse(string("abcdef"));</code><li>自定义cmp参考set,雷同</ul><h4 id="set">set</h4><ul><li>封装红黑平衡二叉树,自动排列元素位置<li>元素值唯一且不可改变,想要遍历只能通过迭代器<li>方法:<ol><li>创建set:<code class="language-plaintext highlighter-rouge">std::set&lt;type&gt; s;</code>或<code class="language-plaintext highlighter-rouge">std::set&lt;int&gt; s(a, a + 3);</code>a为数组<li>获取第一个元素/迭代器:<code class="language-plaintext highlighter-rouge">s.begin();</code><li>获取最后一个元素下一个的索引/迭代器:<code class="language-plaintext highlighter-rouge">s.end();</code><li>返回set容量:<code class="language-plaintext highlighter-rouge">s.size();</code><li>添加元素:<code class="language-plaintext highlighter-rouge">s.insert(element);</code><li>判断某个元素是否存在,返回0或1:<code class="language-plaintext highlighter-rouge">s.count(element);</code><li>返回第一个大于等于a的元素:<code class="language-plaintext highlighter-rouge">s.lower_bound(a);</code><li>返回最后一个大于等于a的元素:<code class="language-plaintext highlighter-rouge">s.upper_bound(a);</code><li>查找元素a,若不存在返回end():<code class="language-plaintext highlighter-rouge">s.find(element);</code><li>set自定义cmp:</ol></ul><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>	<span class="c1">//数据类型不是结构体</span>
	<span class="k">struct</span> <span class="nc">myCmp</span><span class="p">{</span>										<span class="c1">//自定义排序方法 </span>
		<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>	<span class="c1">//从大到小排列 </span>
			<span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myCmp</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span>
	<span class="o">-----------------------------------------------------</span>
	<span class="c1">//数据类型是结构体</span>
	<span class="k">struct</span> <span class="nc">myCmp</span><span class="p">{</span>								<span class="c1">//自定义排序方法 </span>
			
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
		<span class="kt">float</span> <span class="n">score</span><span class="p">;</span>
		
		<span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">myCmp</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span>	<span class="c1">//从小到大排列 </span>
			<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">myCmp</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span>

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cpp/'>cpp</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%9F%BA%E7%A1%80/" class="post-tag no-text-decoration" >基础</a> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++知识点总结目录 - voidblank&url=https://voidblank.github.io/posts/cpp/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++知识点总结目录 - voidblank&u=https://voidblank.github.io/posts/cpp/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++知识点总结目录 - voidblank&url=https://voidblank.github.io/posts/cpp/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vuex/">Vuex</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><li><a href="/posts/spring-boot-%E6%B3%A8%E8%A7%A3/">SpringBoot 注解</a><li><a href="/posts/enable-google-pv/">Enable Google Page Views</a><li><a href="/posts/abstract-queued-synchronizer/">AQS</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/JavaScript/"><div class="card-body"> <span class="timeago small" > Apr 18 <i class="unloaded">2021-04-18T14:03:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JavaScript</h3><div class="text-muted small"><p> JavaScript 输出 window.alert()：弹出警告框 document.write()内容输出到html文档中 如果在html加载完成后执行该函数，则会使html内容被覆盖 document.getElementById("demo").innerHTML:将id=demo的内容改写 console.log()：输出到...</p></div></div></a></div><div class="card"> <a href="/posts/css/"><div class="card-body"> <span class="timeago small" > May 16 <i class="unloaded">2021-05-16T13:59:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CSS基础</h3><div class="text-muted small"><p> CSS 语法 {}内为k-v对，使用分号分割 注释:/* */ 基本 1 2 3 4 p { color: blue; front-size: 12px; } p表示指示器 ID选择器 1 2 3 4 5 #param1 { color: blue; front-size: 12px; } 使用#开始的，表示i...</p></div></div></a></div><div class="card"> <a href="/posts/python/"><div class="card-body"> <span class="timeago small" > Apr 10 <i class="unloaded">2021-04-10T16:36:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python知识点总结目录</h3><div class="text-muted small"><p> Python 知识点总结目录 数值数据类型 整数:int 浮点型:float,double,decimal 复数:complex 序列和容器 str字符串 可以使用for进行遍历 可以使用”“或是’‘,视情况而定，一般最外层用”” r"C:\string"相当于"C:\\string" 在string中使用’’’ ‘'’可以换行存储字符串,保留换行格式...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/vuex/" class="btn btn-outline-primary" prompt="Older"><p>Vuex</p></a> <a href="/posts/thread/" class="btn btn-outline-primary" prompt="Newer"><p>Thread</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">voidblank</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="post-tag" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/java%E6%BA%90%E7%A0%81/">java源码</a> <a class="post-tag" href="/tags/jdk1-8/">JDK1.8</a> <a class="post-tag" href="/tags/%E5%90%8E%E5%8F%B0/">后台</a> <a class="post-tag" href="/tags/vue/">vue</a> <a class="post-tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://voidblank.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
