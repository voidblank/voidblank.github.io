---
title: 数据结构与算法
author: voidblank
date: 2021-04-10 16:42:00 +0800
categories: [Algorithm]
tags: [基础, 数据结构, 算法]
math: true
mermaid: true
---

# 数据结构与算法

## 线性表
- 线性结构,头节点无前驱有一个后继,尾节点无后继有一个前驱。
- 只能顺序查找,查找时间复杂度O(n),删除时间复杂度O(1)

### 数组
- 顺序存储,连续存储,方便查找,可以随机查找元素,删除和插入较慢。
- 多维数组不是线性表
- 插入:时间复杂度O(n)
- 删除:时间复杂度O(n)
- 查找:时间复杂度O(n)

### 线性链表
- 链式存储结构,可以不连续存储(可散和连续),方便插入删除,不能随机查找元素,查找元素较慢。
- 插入:时间复杂度:表头O(1),表中O(n)
- 删除:时间复杂度:表头O(1),表中O(n)
- 查找:时间复杂度O(n)

### 循环链表
- 头尾相接的链表,可以不连续存储(可散和连续),方便插入删除,不能随机查找元素,查找元素较慢。
- 插入:时间复杂度:表头O(1),表中O(n)
- 删除:时间复杂度:表头O(1),表中O(n)
- 查找:时间复杂度O(n)

### 双向链表
- 单链表的基础上,每一个结点里增加一个指针指向其前驱的指针域,使得链表可以从首尾两端进行处理。
- 插入:时间复杂度:表头表尾O(1),表中O(n)
- 删除:时间复杂度:表头表尾O(1),表中O(n)
- 查找:时间复杂度O(n)

### 跳表
- 待定

## 栈和队列

### 栈
- 限制在一端进行增删操作的线性表,增删端称为栈顶(top),另一端称为栈底(bottom),先进后出的元素顺序。
- 链式存储结构,栈顶指针就是链表的头指针,删除时(pop)需要判断栈空。
- 插入:时间复杂度O(1)(push在栈顶)
- 删除:时间复杂度O(1)(pop在栈顶)
- 查找:不提供查找方法。

### 队列
- 限制在一端进行删除操作,另一端进行插入操作的线性表,删除端称为队头(front),另一端称为队尾(rear),先进先出的元素顺序。

#### 顺序队列
- 顺序存储结构,头尾指针相等时为空队列。非空队列时,头指针指向队列头,尾指针指向队列最后一个元素。
- 插入:时间复杂度O(1)(仅队头)
- 删除:时间复杂度O(1)(仅队尾)
- 查找:不提供查找方法

#### 循环队列
- ![](https://images2015.cnblogs.com/blog/991470/201610/991470-20161017231834998-843574485.png)
- 头尾相接的队列,添加元素时rear指针增加,删除元素时front指针增加,当rear->next为head时,可能为空也可能为满
- 必须给定MaxSize,基于数组实现
- 插入:时间复杂度O(1)(队头)
- 删除:时间复杂度O(1)(队尾)
- 查找:不提供查找方法

## 树

- 非线性结构,递归结构
- 基本用语:
	- 树结点:包含一个数据元素和若干个指向子树的分支的点。
	- 孩子结点:结点的子树的根称为该结点的孩子。
	- 双亲结点:指向孩子结点的结点。
	- 兄弟结点:同一个双亲结点下的其他孩子结点。
	- 堂兄结点:同一层的其他结点。
	- 结点层次:根结点为层次1,根节点的孩子结点为层次2,以此类推。
	- 树的高/深度:树中最大的结点层。
	- 结点的度:结点子树的个数。
	- 树的度:树中最大的结点数。
	- 叶子结点:没有孩子结点的结点。
	- 分枝结点:有孩子结点的点。
	- 森林:互不相交的树的集合。
	- 有序树:子树有序的树,如家族树。
	- 无序树:子树无序的树。
- 二叉树:
	- ![](https://images2015.cnblogs.com/blog/1094457/201702/1094457-20170225194740741-9886325.png)
	- 二叉树一定区分左子树和右子树,即使这个树结点下只有一个孩子结点。
	- 二叉平衡树一定是一棵二叉排序树。堆不是一棵二叉平衡树。
	- 在二叉树的第i层至多有2<sup>i-1</sup>个根结点。
	- 深度为k的二叉树上至多有2<sup>k</sup>-1个结点。
	- 对于任何一棵二叉树,若他有n<sub>0</sub>个叶子结点,n<sub>2</sub>个度为2的结点,那么一定存在:n<sub>0</sub> = n<sub>2</sub> + 1
	- 具有n个结点的完全二叉树的深度为⎣log<sub>2</sub> n⎦+1
	- 一棵含有n个结点的按层序编号的完全二叉树,那么对于任何一个结点i(1<=i<=n)来说:
		- i=1时,表示二叉树的根;i>1时,双亲结点的编号为:i/2(向下取整)
		- 若2i>n,则i无左孩子;否则,左孩子结点为2i
		- 若2i+1>n,则i无右孩子;否则,右孩子结点为2i+1
	- 二叉树的遍历:
		- 前序遍历:ABDHIEJKCFLMGNO(根节点->左子树->右子树)
		- 中序遍历:HDIBJEKALFMCNGO(左子树->根节点->右子树)
		- 后序遍历:HIDJKEBLMFNOGCA(左子树->右子树->根节点)
		- 深度优先遍历二叉树是栈
		- 广度优先遍历二叉树是队列
	- 二叉树存储结构:
		- 顺序存储结构或是链式存储结构。
		- 链式存储结构:每个结点存储左子树和右子树。
	- 线索二叉树:
		- 二叉树中,叶子结点的左右子树结点都为空,为了将空域使用起来,将这些空指针指向树中的其他结点。
		- 已知某个结点为ptr,那么建立线索的原则:
			- 若ptr->lchild == null,那么ptr的lchild存放ptr结点在中序遍历中该结点的前驱结点,这个结点称为ptr的中序前驱。
			- 若ptr->rchild == null,那么ptr的rchild存放ptr结点在中序遍历中该结点的后驱结点,这个结点称为ptr的中序后继。
			- 例如:图中H的lchild指向null,rchild指向D;图中I的lchild指向D,rchild指向B。
		- 好处:对一个线索化后的二叉树进行中序遍历时,只需要从lchild指向null的结点开始,一直查找他的右子树即可。

## 图
- 图分为无向图和有向图。

### 无向图
- 基本用语:
  - 回路/环:第一个顶点和最后一个顶点相同的路径。
  - 简单回路/环:除了第一个顶点和最后一个顶点外,其他的顶点不重复出现的回路。
  - 连通:顶点v<sub>1</sub>与顶点v<sub>2</sub>之间有路径存在。
  - 连通图:无向图中任意两点之间都是连通的。
  - 连通分量:一个图中的极大连通子图。连通图只有一个连通分量,即它本身。一个连通分量一定是一个环。一个点也可以作为一个连通分量。
  - 极大连通子图:包含所有的边的,连通的,子图。
  - 极小连通子图:保持图连通,同时边数最少的图。
- 无向图算法:
  - 深度优先搜索(depth-first-search, dfs):
    - 使用栈实现。
    - 解决问题:
      1. 判断某个点能抵达的所有点。
      2. 判断两个点是否连通,若连通则求路线。
    - 简单概括:从某个点开始,一直检索到尽头,重复多次,直至没有路线可走。
    - 遍历过的点,在其他路线中遇到时不再遍历。
    - 可以通过这个方法可以判断是否连通(flag)。
  - 广度优先搜索(breathth-first-search, bfs):
	- 使用队列实现。
	- 解决问题:
      1. 寻找最短路径
	- 简单概括:从某个点开始,将他所能走到的所有点都遍历,获得到这些点的距离(distance),再通过这些可到达的点继续向外遍历,遍历过的点不再遍历。
	- flag为true的点将不再遍历。
	- 可以通过这个方法获取两个点之间的最短距离。

### 有向图
- 基本用语:
  - 强连通图:任意两点可连通的图。
  - 强连通分量:最大连通子图。注意有向图和无向图略有区别。
- 有向图算法:
  - 深度优先搜索(dfs)：
	- 同无向图。
  - 广度优先搜索(bfs):
	- 同无向图。
  - Dijkstra算法(加权有向图上单源最短路径):
	- 不能有负权值边。
  - 拓扑排序(Topological Sort):
	- ![](https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190123104846553-765518846.png)
	- 左侧为图,右侧为拓扑排序后的图。
	- 注意:拓扑排序中不能有环。
	- 可以处理有向无环图的最短路径问题,效率高于Dijkstra算法,但是也不能有负权值边。
  - Bellman-Ford algorithm(贝尔曼-福特算法):
	- 处理两点最短路径问题,权值可以有负数。
	- 不能有总权值为负的内部循环。

### 处理图的方法 
- 邻接矩阵:
  - 使用一个矩阵(即二维数组),1表示连通,0表示不连通
  - 点多的时候,矩阵将十分巨大,而且0会占用大量空间。
- 邻接列表:
  - 使用一个一维数组(但每个位置存储的是一个不定长数组,参考python),存储的元素表示连通的点。
  - 适合每个点只与少量点相邻的情况。

## 散列表/哈希表

- 在记录的存储地址和它的关键字之间建立一个确定的对应关系,这样不必经过比较就可以直接获取元素。
- 适合查找,不适合频繁更新。
- 时间复杂度取决于Hash算法的有效性。在最好的情况下:
	- 插入:时间复杂度O(1)
	- 删除:时间复杂度O(1)
	- 查找:时间复杂度O(1)
- 常用的哈希函数:
	- 直接定址法:满足H(key) = a * key + b,仅适于数组容量 = 元素个数的情况。
	- 数字分析法:对关键字进行分析,取关键字的若干位或组合作为哈希地址。仅适于能预先估计出全体关键字的频度。例如身份证号存储,使用后5位作为地址进行存储。
	- 平方取中法:将关键字平方后取中间的几位数作为存储地址。适于数据长度较小且事先不知道数据的情况。
	- 折叠法:数字位数较多时,可以将数组分割为几个部分,在将这几个部分进行叠加,取和作为哈希地址(可以只取和的几位)。例如,存储123456789这个数,则:1+2+3=6,4+5+6=15,7+8+9=24,和为61524,取后三位作为地址524
	- 除留余数法:H(key) = key MOD p(p<=m,m为表长),一般p取素数。一般使用方法。
- 哈希冲突:
	- 当不同的key对应同一个地址时,称为产生了哈希冲突。
	- 开放定址法:
		- 当冲突发生时,形成一个探查序列:沿此序列逐个进行地址探查,直至找到一个空位置。
		- 新的地址:H<sub>i</sub> = (H(key) + d<sub>i</sub>) % m(m为表长)
		- d<sub>i</sub>的取法:
			- 线性探测再散列:d<sub>i</sub> = 1,2,3...,m-1
			- 平方探测再散列:d<sub>i</sub> = 1<sup>2</sup>, -1<sup>2</sup>, 2<sup>2</sup>...
			- 随机探测再散列:d<sub>i</sub>为伪随机数序列
		- 缺点:
			- 不能真正的删除某个值,只能在被删除的值上做标记。
			- 实际可能会产生聚集的情况。
			- 可能会浪费空间。
	- 链地址法:
		- 在产生冲突的存储数据后面加一个指针,指向后面冲突的数据。
		- 指针实际占用空间小,因此该方法节省空间;操作简单,不会产生其他问题。

## 冒泡排序(Bubble Sort)

- 从第一个数开始,比较相邻两个数的大小,重复N次
- 时间复杂度:O(n<sup>2</sup>)
- 设置判断位flag,若某一次遍历没有发生交换,那么说明已经排好序了,不需要再次排序。
- 稳定排序。

## 选择排序(Selection Sort)

- 第一次遍历数组,找到最小的值放在第一位;第二次遍历n-1数组,找到次小值放在第二位...重复N次
- 时间复杂度:O(n<sup>2</sup>)
- 不稳定排序。

## 插入排序(Insertion Sort)

- 将前n-1个数排好序,然后将第n个数插入进去,如同在扑克游戏中,在手牌中加入一张牌
- 时间复杂度:O(n<sup>2</sup>)
- 稳定排序。

## 希尔排序(Shell Sort)

- 将一个序列分成2组,前一组的对应的和后一组的对应的进行比较,之后再将这两组分别分成两组,继续比较...
- 时间复杂度:O((nlog(n))<sup>2</sup>)
- 不稳定排序。

## 快速排序(Quick Sort)

- 分治法思想。
- 选择一个基准数放到序列最前端,然后对后面的序列作如下操作:从前遍历直至找到比基准数大的数a,从后面遍历直至找到比基准数小的数b,将后面的小的数b放在首位,将前面的大的数a放在原来b的位置,将基准数放在原来a的位置,完成第一次排序。对基准数现在的位置起,前面的进行排序,后面的进行排序。
- 最差时间复杂度:O(n<sup>2</sup>),一般使用期望复杂度:O(nlog(n))
- 基准数可以选取第一位,但若是序列本身有序的时候就会变成冒泡排序;一般使用随机选取,从left到right间随机选取一个数作为基准数,将他放在最前面进行排序。
- 不稳定排序。

## 归并排序(Merge Sort)

- 分治法思想。
- 将大的序列分成若干个小的,有序的序列,将小的有序序列进行排序,最终汇成大的序列。
- 时间复杂度:O(nlog(n))
- 稳定排序。

## 基数排序(Radix Sort)

- 桶排序的升级版,节约了内存空间。
- 将序列中的每个数进行如下的操作:第一次遍历:根据它的最低位,将它存进一个容量为10的数组,例如49存进数组[9][cnt]中,最后将数按照顺序存回原来的序列里。第二次遍历,按照十位的数字进行存储,以此类推,直至到所有数的最高位为止。
- 时间复杂度:O(nlog(n))
- 稳定排序。

## 分治法

- 思想:
	- 将原来的问题分解为几个规模较小但类似于原问题的子问题,递归地求解这些子问题,然后再合并这些子问题的解来建立原问题的解。
- 每层递归的三个步骤:
	- 分解:分解原问题为若干个子问题,这些子问题是原问题的规模较小的实例。
	- 解决:解决这些子问题,递归地求解各子问题。
	- 合并:合并这些子问题的解成原问题的解。
	- 例:归并排序
		- 分解待排序的n个元素的序列成各具n/2个元素的两个字序列。
		- 使用归并排序递归地排序两个子序列。
		- 合并两个已排序的子序列以产生已排序的答案。

## 动态规划

- 动态规划和分治法近似,处理子问题重叠的情况。
- 将不同的子问题具有的公共子子问题(子问题的求解时递归进行的,将其划分为更小的子子问题)。分治法在处理这种重叠问题时,会对重叠部分进行多次重叠计算,而动态规划对每个子子问题只求解一次。
- 动态规划的步骤:
	- 刻画一个最优解的结构特征。
	- 递归的定义最优解的值。
	- 计算最优解的值,通常采用自底向上的方法。
	- 利用计算出的信息构造一个最优解。

## 贪心算法

- 求解最优问题,类似动态规划,但效率更高。某些情况下得不出真正的结果。
- 在每一步做出当时看来最优的选择,即总是做出局部最优选择,寄希望这样可以导致全局最优解。
- 贪心算法的步骤:
	- 将最优问题转化为这样的形式:对其作出一次选择后,只剩下一个子问题需要求解。
	- 证明做出贪心选择后,原问题总是存在最优解,即贪心选择总是安全的。
	- 证明做出贪心选择后,剩余的子问题满足性质:其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。
- 例子:01背包问题
	- 贪心策略1:选取价值最大者
	- 贪心策略2:选取重量最大者
	- 贪心策略3:选取单位重量下价值最大者
- 例子:Dijkstra算法(加权有向图上单源最短路径)

